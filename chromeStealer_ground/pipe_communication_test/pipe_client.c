// Moved from Zeyang's test branch

#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <time.h>

#define debug

#ifdef debug
#define debug_printf(...)  printf(__VA_ARGS__)
#else
#define debug_printf(...)
#endif

#define BROADCAST_PORT 6983 
#define BROADCAST_INTERVAL 2  // Broadcast every 2 seconds if no message received
#define BUFSIZE 4096

typedef struct pipeMessage {
    LPSTR lpPipeServerName;
    LPBYTE lpcbRequest;
    DWORD cbRequestBytes;
    LPBYTE lpcbReply;
    DWORD cbReplyBytes;
} PIPEMSG;

BOOL getPipeHostName(LPSTR targetHostName, DWORD nameLenth) {

    WSADATA wsaData;
    int wsaStartup = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (wsaStartup != 0) {
        debug_printf("WSAStartup failed: %d\n", wsaStartup);
        return FALSE;
    }

    SOCKET sock;
    sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sock == INVALID_SOCKET) {
        debug_printf("Socket creation failed\n");
        return FALSE;
    }

    // Set the socket to allow broadcasts
    int broadcastPermission = 1;
    if (SOCKET_ERROR == setsockopt(
                            sock,
                            SOL_SOCKET,
                            SO_BROADCAST,
                            (char *)&broadcastPermission,
                            sizeof(broadcastPermission))) {
        debug_printf("Failed to set socket to broadcast mode\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }

    // Set socket to non-blocking mode
    u_long mode = 1;  // 1 to enable non-blocking socket
    ioctlsocket(sock, FIONBIO, &mode);

    struct sockaddr_in broadcastAddr, recvAddr;
    int addrLen = sizeof(recvAddr);
    char *broadcastIP = "255.255.255.255";
    // Set up the broadcast address
    memset(&broadcastAddr, 0, sizeof(broadcastAddr));
    broadcastAddr.sin_family = AF_INET;
    broadcastAddr.sin_addr.s_addr = inet_addr(broadcastIP);
    broadcastAddr.sin_port = htons(BROADCAST_PORT);

    char *message = "CS6983";
    struct timeval timeout;
    fd_set readfds;
    while (TRUE) {
        // Set up the timeout for select
        timeout.tv_sec = BROADCAST_INTERVAL;
        timeout.tv_usec = 0;

        FD_ZERO(&readfds);
        FD_SET(sock, &readfds);

        int result;
        result = select(0, &readfds, NULL, NULL, &timeout);
        if (result > 0) {
            // There's incoming data - process it
            char recvBuf[32];
            result = recvfrom(sock, recvBuf, sizeof(recvBuf), 0, (struct sockaddr *)&recvAddr, &addrLen);
            // result should count the last NULL terminated byte if sender included it
            // please take care of this when use strcmp or other function
            if (result > 0) {
                printf("Received message length:%d\n", result);
                printf("Received message: %.*s\n", result, recvBuf);
                if (result <= nameLenth) {
                    strncpy(targetHostName, recvBuf, result);
                    break;
                } else {
                    // the server name is too long
                    debug_printf("server name too long for client\n");
                }
            }
        } else if (result == 0) {
            // Timeout occurred - no message received
            // Broadcast message
            sendto(
                sock,
                message,
                strlen(message) + 1,
                0,
                (struct sockaddr *)&broadcastAddr,
                sizeof(broadcastAddr));
            printf("Timed out, Broadcast message sent\n");
        }
    }

    closesocket(sock);
    WSACleanup();

    return TRUE;
}

DWORD WINAPI client2(LPVOID lpvParam) {
    PIPEMSG *msg = (PIPEMSG *)lpvParam;
    BOOL fSuccess = FALSE; 

    debug_printf("Sending %ld bytes message: \"%s\"\n", msg->cbRequestBytes, msg->lpcbRequest); 

    fSuccess = CallNamedPipeA(
        msg->lpPipeServerName,
        msg->lpcbRequest,
        msg->cbRequestBytes,
        msg->lpcbReply,
        BUFSIZ,
        &msg->cbReplyBytes,
        NMPWAIT_WAIT_FOREVER);

    if (FALSE == fSuccess) {
        printf("pipe connect failed, error num:%ld\n", GetLastError());
        return -1;
    }

    printf("\"message form server:%s\"\nlength:%ld\n", msg->lpcbReply, msg->cbReplyBytes); 
    printf("<End of message>\n");

    return 0; 
}

int main() {

    char serverName[MAX_COMPUTERNAME_LENGTH + 1] = {0};
    char pipeServerName[128] = {0};
    DWORD bufferSize = MAX_COMPUTERNAME_LENGTH + 1;
    
    // get pipeHostName until success
    while(!getPipeHostName(serverName, bufferSize));

    // ensure null terminated
    sprintf_s(pipeServerName, 127, "\\\\%s\\pipe\\mynamedpipe", serverName); 

    PIPEMSG clientMessage;
    CHAR lpInMessage[BUFSIZE] = {0} ; 
    CHAR lpOutMessage[BUFSIZE] = {0}; 
    sprintf_s(lpInMessage, 64, "message form client:%ld", GetCurrentProcessId());

    clientMessage.lpPipeServerName = pipeServerName;
    clientMessage.lpcbRequest = (LPBYTE) lpInMessage;
    clientMessage.cbRequestBytes = strlen(lpInMessage) + 1;
    clientMessage.lpcbReply = (LPBYTE) lpOutMessage;
    clientMessage.cbReplyBytes = 0;

    client2((LPVOID) &clientMessage);

    return 0;
}