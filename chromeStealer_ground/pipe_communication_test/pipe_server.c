// Moved from Zeyang's test branch

#include <winsock2.h>
#include <windows.h> 
#include <strsafe.h>

#include <stdio.h> 
#include <string.h>
#include <sodium.h>

#define debug

#ifdef debug
#define debug_printf(...)  printf(__VA_ARGS__)
#else
#define debug_printf(...)
#endif

#define BUFSIZE 512
#define SERVER_PORT 6983 // Example port number
#define SERVER_ADDR             "127.0.0.1"

BOOL pipeThreadSuccess = FALSE;
BOOL listenThreadSuccess = FALSE;

// demo function work as request handling
BOOL GetAnswerToRequest(LPBYTE pchRequest, 
                        DWORD cbRequestBytes,
                        LPBYTE pchReply, 
                        LPDWORD pchBytes) {
    debug_printf("Client Request String:\"%.*s\"\n",(int) cbRequestBytes, (LPSTR)pchRequest);
    // Check the outgoing message to make sure it's not too long for the buffer.
    // demo of string functions from win api
    if (FAILED(StringCchCopyA(
                   (LPSTR)pchReply,
                   BUFSIZE,
                   "default answer from server"))) {
        *pchBytes = 0;
        pchReply[0] = 0;
        debug_printf("StringCchCopy failed, no outgoing message.\n");
        return FALSE;
    }

    /* Get the last 128 bytes of the incoming string and make it the URL */
    
    // Calculate the start of the last 128 bytes
    DWORD startIndex = cbRequestBytes - 128;

    // Allocate buffer for the last 128 bytes + null terminator
    char URL[129] = {0};
    
    // Copy the last 128 bytes into the buffer
    memcpy(URL, pchRequest + startIndex, 128);
    
    // Print the extracted string for demonstration
    debug_printf("URL as String: \"%s\"\n", URL);
    BYTE msg_pipe[4096];
    char buffer_send[4096];
    char buffer_received[4096];
    size_t actualReceivedSize;
    memcpy(msg_pipe, URL, startIndex);
    sodium_bin2base64(buffer_send, sizeof(buffer_send), 
                      msg_pipe, startIndex, sodium_base64_VARIANT_ORIGINAL);

    /* Send to the server */
    // if (sendProtobufData(SERVER_ADDR, SERVER_PORT, URL, 
    //                  buffer_send, custom_strlen(buffer_send), 
    //                  buffer_received, 4096, 
    //                  &actualReceivedSize) != ERROR_SUCCESS) {
    //     debug_printf("[-] Can't send protobuf in Initial Key exchange\n");
    // }
    char* buffer_received = "abcd";
    memcpy(pchReply, buffer_received, actualReceivedSize);

    size_t lenth;
    if (FAILED(StringCchLengthA((LPSTR)pchReply, BUFSIZE, &lenth))) {
        *pchBytes = 0;
        pchReply[0] = 0;
        return FALSE;
    }
    *pchBytes = (DWORD) (lenth + 1);
    return TRUE;
}

// pipe server function, create a pipe instance, read from it
// handle message and write reply back to pipe
DWORD WINAPI server(LPVOID lpvParam) {
    HANDLE hPipe = INVALID_HANDLE_VALUE; 
    LPCTSTR lpszPipename = "\\\\.\\pipe\\mynamedpipe"; 
    LPBYTE pchRequest = NULL;
    LPBYTE pchReply = NULL;

    // Do some extra error checking
    // reqeust and reply buffer size should be adjusted and can be different.
    // if can not allocate enough memroy, quit
    pchRequest = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, BUFSIZE*sizeof(BYTE));
    if (pchRequest == NULL) {
        debug_printf( "MEMORY ALLOCATE ERROR - Pipe Server Failed\n");
        return 1;
    }
    pchReply = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, BUFSIZE*sizeof(BYTE));
    if (pchReply == NULL) {
        debug_printf( "MEMORY ALLOCATE ERROR - Pipe Server Failed\n");
        return 1;
    }

    for (;;) {
        hPipe = CreateNamedPipeA( 
            lpszPipename,                 // pipe name 
            PIPE_ACCESS_DUPLEX,           // read/write access 
            PIPE_TYPE_MESSAGE |           // message type pipe 
            PIPE_READMODE_MESSAGE |       // message-read mode 
            PIPE_WAIT |                   // blocking mode
            PIPE_ACCEPT_REMOTE_CLIENTS,   // remote access              
            PIPE_UNLIMITED_INSTANCES,     // max instances  
            BUFSIZE,                      // output buffer size 
            BUFSIZE,                      // input buffer size 
            NMPWAIT_WAIT_FOREVER,         // client time-out 
            NULL);                        // default security attribute 

        if (INVALID_HANDLE_VALUE == hPipe) {
            debug_printf("CreateNamedPipe failed, GLE=%ld.\n", GetLastError()); 
            // create pipe until success
            continue;
        }

        debug_printf("Pipe Server: server thread awaiting client connection on %s\n", lpszPipename);
        pipeThreadSuccess = TRUE;

        for (;;) { 
            // Wait for the client to connect; if it succeeds,
            // the function returns a nonzero value. If the function
            // returns zero and GetLastError returns ERROR_PIPE_CONNECTED,
            // it is also fine.
        
            BOOL fConnected = FALSE; 
            fConnected = ConnectNamedPipe(hPipe, NULL) ? 
                TRUE : (GetLastError() == ERROR_PIPE_CONNECTED); 
        
            if (fConnected) { 
                debug_printf("Client connected\n"); 
            } else {
                // The client could not connect, so close the pipe
                // and create pipe again
                CloseHandle(hPipe); 
                debug_printf("The client could not connect, so close the pipe.\n");
                break;
            }

            DWORD cbBytesRead = 0, cbReplyBytes = 0, cbWritten = 0; 
            BOOL fSuccess = FALSE;
            // Loop until done reading
            while (TRUE) { 
            // Read client requests from the pipe. This simplistic code only allows messages
            // up to BUFSIZE characters in length.
                fSuccess = ReadFile( 
                    hPipe,                  // handle to pipe 
                    pchRequest,             // buffer to receive data 
                    BUFSIZE * sizeof(BYTE), // size of buffer 
                    &cbBytesRead,           // number of bytes read 
                    NULL);                  // not overlapped I/O 

                if (!fSuccess || cbBytesRead == 0) {   
                    if (GetLastError() == ERROR_BROKEN_PIPE) {
                        debug_printf("client disconnected.\n"); 
                    } else {
                        debug_printf("ReadFile failed, GLE=%ld.\n", GetLastError()); 
                    }
                    break;
                }
                // Process the incoming message.
                GetAnswerToRequest(pchRequest, cbBytesRead, pchReply, &cbReplyBytes);
                // Write the reply to the pipe. 
                fSuccess = FALSE;
                fSuccess = WriteFile( 
                               hPipe,        // handle to pipe 
                               pchReply,     // buffer to write from 
                               cbReplyBytes, // number of bytes to write 
                               &cbWritten,   // number of bytes written 
                               NULL);        // not overlapped I/O 
                if (!fSuccess || cbReplyBytes != cbWritten) {   
                    debug_printf("InstanceThread WriteFile failed, GLE=%ld.\n", GetLastError()); 
                    break;
                }
                // Flush the pipe to allow the client to read the pipe's contents 
                // before disconnecting.
                FlushFileBuffers(hPipe); 
            }
            // Disconnect the pipe instance
            DisconnectNamedPipe(hPipe); 
            debug_printf("server finish 1 connect\n");
        }
    }

    return 0;
}

// listen all local networks and send hostname to valid client
DWORD WINAPI serverListen(LPVOID lpvParam) {
    WSADATA wsaData;
    char serverName[MAX_COMPUTERNAME_LENGTH + 1] = {0};
    DWORD bufferSize = MAX_COMPUTERNAME_LENGTH + 1;

    int wsaStartup = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (wsaStartup != 0) {
        debug_printf("WSAStartup failed: %d\n", wsaStartup);
        return 1;
    }
    if (!gethostname(serverName, bufferSize)) {
        debug_printf("Server Name: %s\n", serverName);
    } else {
        debug_printf("Error getting server name: %ld\n", GetLastError());
        debug_printf("error:%d\n", WSAGetLastError());
        WSACleanup();
        return 1;
    }

    SOCKET serverSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (INVALID_SOCKET == serverSocket) {
        debug_printf("Socket creation failed.\n");
        WSACleanup();
        return 1;
    }
    SOCKADDR_IN serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);  // Listen on all interfaces
    serverAddr.sin_port = htons(SERVER_PORT);

    if (SOCKET_ERROR == bind(serverSocket, (SOCKADDR *)&serverAddr, sizeof(serverAddr))) {
        fprintf(stderr, "Bind failed.\n");
        closesocket(serverSocket);
        WSACleanup();
        return 1;
    }

    listenThreadSuccess = TRUE;

    while (TRUE) {
        char buffer[32] = {0};
        struct sockaddr_in clientAddr;
        int clientAddrSize = sizeof(clientAddr);
        int receivedBytes = recvfrom(
                                serverSocket,
                                buffer,
                                sizeof(buffer),
                                0,
                                (struct sockaddr *)&clientAddr,
                                &clientAddrSize);

        if (receivedBytes > 0) {
            // Process the received data and reply
            debug_printf("from ip address:%s\n", inet_ntoa(clientAddr.sin_addr));
            debug_printf("Receive: %.*s\n", receivedBytes, buffer);
            // do some check in buffer, if valid then send else ignore
            if (0 != strncmp(buffer, "CS6983", 32)) {
                debug_printf("check failed\n");
                continue;
            }
            sendto(
                serverSocket,
                serverName,
                strlen(serverName) + 1,
                0,
                (struct sockaddr *)&clientAddr,
                clientAddrSize);
        } else {
            debug_printf("error while receiving\n");
        }
    }

    return 0;
}


int main(int argc, char *argv[]) {
    HANDLE hServerThread;
    HANDLE hListenThread;
    DWORD i = 0;

    hServerThread = CreateThread(NULL, 0, server, NULL, 0, NULL); 
    hListenThread = CreateThread(NULL, 0, serverListen, NULL, 0, NULL); 

    while (!pipeThreadSuccess && !listenThreadSuccess && i < 20) {
        i++;
        Sleep(1000);
    }
    if (pipeThreadSuccess && listenThreadSuccess) {
        printf("\nThread created success!!\n");
    } else {
        // maybe consider create thread again
    }

    // two threads should never return
    // the wait function ensure main thread not exit
    WaitForSingleObject(hServerThread, INFINITE);
    WaitForSingleObject(hListenThread, INFINITE);
    // CloseHandle(hServerThread);

    return 0;
}