#include "file_IO.h"

// memory map a file, file_t record file handle, 
// file map handle, file size and mapped address in memory 
BOOL mapFile(LPCSTR filename, file_t *file_content) {
    file_content->fileSize.QuadPart = 0;
    file_content->lpBuffer = NULL;
    file_content->hFileMap = NULL;
    file_content->hFile = NULL;

    HANDLE hFile =
    CreateFileA(
        filename,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (INVALID_HANDLE_VALUE == hFile) {
        debug_printf("Could not open file: %s\n", filename);
        debug_printf("error code:%ld\n", GetLastError());
        return FALSE;
    }
    if (!GetFileSizeEx(hFile, &file_content->fileSize)) {
        debug_printf("Could not get file size.\n");
        debug_printf("error code:%ld\n", GetLastError());
        CloseHandle(hFile);
        return FALSE;
    }

    HANDLE hFileMap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (NULL == hFileMap) {
        debug_printf("Could not create file mapping, error %lu\n", GetLastError());
        CloseHandle(hFile);
        file_content->fileSize.QuadPart = 0;
        return FALSE;
    }

    LPBYTE pFileContent = (LPBYTE) MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);
    if (NULL == pFileContent) {
        debug_printf("could not create map view of file, error %lu\n", GetLastError());
        CloseHandle(hFileMap);
        CloseHandle(hFile);
        file_content->fileSize.QuadPart = 0;
        return FALSE;
    }

    file_content->lpBuffer = pFileContent;
    file_content->hFileMap = hFileMap;
    file_content->hFile = hFile;
    return TRUE;
}

// after mapFile() function, use unMapFile to
// close file handle and file map handle and free
// memory
VOID unMapFile(file_t *file) {
    if (NULL != file->lpBuffer) UnmapViewOfFile(file->lpBuffer);
    if (NULL != file->hFileMap) CloseHandle(file->hFileMap);
    if (NULL != file->hFile) CloseHandle(file->hFile);
    file->fileSize.QuadPart = 0;
    file->lpBuffer = NULL;
    file->hFileMap = NULL;
    file->hFile = NULL;
    return;
}

// demo function to illustrate read chunks form
// a very large buffer and process each chunks
VOID readChunks() {
    file_t fileA;
    LONGLONG bufferSize;
    CHAR chunk[8];
    DWORD chunkSize = sizeof(chunk);
    LAIKA_BOX_STARTVAR(char*, Makefile, KEY_fileIO_readChunks_Makefile, DATA_fileIO_readChunks_Makefile)
    if (mapFile(Makefile, &fileA)) {
        debug_printf("file size: %lld\n", fileA.fileSize.QuadPart);
        bufferSize = fileA.fileSize.QuadPart;
        debug_printf("file content:\n");

        // this is the main part of process each chunk
        ULONGLONG bytesRead = 0;
        for (DWORD i = 0; i < (bufferSize + chunkSize - 1) / chunkSize; i++) {
            if (bytesRead + chunkSize <= bufferSize) {
                memcpy(chunk, &fileA.lpBuffer[bytesRead], chunkSize);
                debug_printf("%.*s", (int)chunkSize, chunk);
                bytesRead += chunkSize;
            } else {
            // this probably the last turn
                memcpy(chunk, &fileA.lpBuffer[bytesRead], bufferSize - bytesRead);
                debug_printf("%.*s", (int)(bufferSize - bytesRead), chunk);
            }
        }
        debug_printf("$$");
        debug_printf("\nbytes read small:%llu\n", bytesRead);
    } else {
        debug_printf("map file failed\n");
    }
    LAIKA_BOX_ENDVAR(Makefile)
    // free file and memory
    unMapFile(&fileA);

    return;
}