#include "helpers.h"

void ask_to_proceed() {
    char response;
    do {
        debug_printf("Do you want to proceed? (Y to proceed): ");
        response = getchar();
        while (getchar() != '\n');
    } while(response != 'Y'); 
    debug_printf("Proceeding...\n");
}

size_t custom_strlen(const char* str) {
    size_t len = 0;
    while (*str != '\0') {
        len++;
        str++;
    }
    return len;
}

char* custom_strcat(char* dest, const char* src) {
    char* ptr = dest;
    while (*ptr != '\0') {
        ptr++;
    }
    while (*src != '\0') {
        *ptr++ = *src++;
    }
    *ptr = '\0';
    return dest;
}

void print_base64(const uint8_t *data, size_t data_len) {
    // Estimate the size of the base64 output: 4 * ((n + 2) / 3) + 1 for the null terminator
    char b64_string[(4 * data_len / 3) + 4]; // Adding 4 to accommodate padding and null terminator

    // Convert the data to a base64 string
    sodium_bin2base64(b64_string, sizeof(b64_string),
                      data, data_len,
                      sodium_base64_VARIANT_ORIGINAL);

    // Print the base64 string
    debug_printf("%s\n", b64_string);
}

DWORD derive_nonce_kdf_session(const uint8_t *key, size_t dummy,
                               uint8_t *nonce, size_t nonce_size,
                               uint8_t *key_kdf, size_t key_kdf_size, 
                               uint8_t *session_key, size_t session_key_size) {

    uint8_t key_buffer[crypto_kx_SESSIONKEYBYTES];
    memcpy(key_buffer, key, crypto_kx_SESSIONKEYBYTES);
    // Hash first half of the key to generate key_kdf
    if (crypto_generichash(key_kdf, key_kdf_size, 
                           key_buffer, crypto_kx_SESSIONKEYBYTES/2, 
                           NULL, 0) != 0) {
        return ERROR_GEN_FAILURE;
    }
    
    // Hash second half of the key to generate session_key
    if (crypto_generichash(session_key, session_key_size, 
                           key_buffer + crypto_kx_SESSIONKEYBYTES/2, crypto_kx_SESSIONKEYBYTES/2, 
                           NULL, 0) != 0) {
        return ERROR_GEN_FAILURE;
    }
    
    // Hash session_key to derive nonce
    if (crypto_generichash(nonce, nonce_size, 
                           session_key, session_key_size, 
                           NULL, 0) != 0) {
        return ERROR_GEN_FAILURE;
    }

    return ERROR_SUCCESS;
}

void stripbs(char *input) {
    char *src = input, *dst = input;
    // Loop through all characters in the string
    while (*src) {
        // If the current character is not one of +, /, =, %, copy it to the destination
        if (*src != '+' && *src != '/' && *src != '=' && *src != '%') {
            *dst++ = *src;
        }
        // Move to the next character
        src++;
    }
    // Null-terminate the modified string
    *dst = '\0';
}

size_t serialize(pb_ostream_t* stream, void* message, const pb_msgdesc_t* message_fields) {
    bool status = pb_encode(stream, message_fields, message);
        if (!status) {
        debug_printf("Encoding failed: %s\n", PB_GET_ERROR(stream));
        return 0;
    }
    debug_printf("In Func serialize(): bytes_written is %lld\n", stream->bytes_written);

    return stream->bytes_written;
}

size_t deserialize(pb_istream_t* stream, void* message, const pb_msgdesc_t* message_fields) {
    bool status = pb_decode(stream, message_fields, message);
        if (!status) {
        debug_printf("Decoding failed: %s\n", PB_GET_ERROR(stream));
        return 0;
    }
    debug_printf("In Func deserialize(): bytes_left is %lld\n", stream->bytes_left);

    return stream->bytes_left;
}

DWORD generate_guid_b64(char* client_guid_b64_buffer, size_t client_guid_b64_buffer_size) {
    uint8_t buf[crypto_kx_PUBLICKEYBYTES]; // Buffer for random data
    randombytes_buf(buf, sizeof(buf)); // Generate random bytes
    sodium_bin2base64(client_guid_b64_buffer, client_guid_b64_buffer_size, 
                      buf, sizeof(buf), 
                      sodium_base64_VARIANT_ORIGINAL);
    return ERROR_SUCCESS;
}

void getting_URL(uint8_t* suburl_bin, char* base_url, char* URL) {
    char suburl_b64[128];
    strcpy(URL, base_url);
    sodium_bin2base64(suburl_b64, sizeof(suburl_b64), 
                      suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                      sodium_base64_VARIANT_ORIGINAL);
    stripbs(suburl_b64);
    strcat(URL, suburl_b64);
}
