Poster demonstrating the hightlights: https://docs.google.com/presentation/d/1wMscivXkOunHQQh3uvCia9BISM7JXRdkxXm1IBD_QLk/edit?usp=sharing
Take a look please! 

Hello! Thank you for your time reading this. This is the code repository for the final project of Northeastern University CS6983 (Malware Development) teaching by Professor Kai Bernardini. 

C2 servers, also known as C&C servers or C2 nodes, serve as the linchpin of cyberattacks, allowing threat actors to remotely manage and coordinate their malicious operations.[1] Consider this scenario, an employee unwittingly clicked on an executable, and the organizations data got exfiltrated to a remote server, or code is being executed by a remote attacker. 

In this project, we have built a C2 server along with a implant client to simulate this scenario, in an attacker perspective. The implant client will be executed and infect the target system, and the C2 server can control its behavior.

It's a fully functional Command & Control framework consisting of: 
1. A dropper that will download the main implant into memory and execute after launching
2. A main implant that connects and communicates with a remote C2 server
3. A C2 server that controls all of the implants dropped
 
This README can show you a little bit of what we have done / what you can expect. You can find the main program under /chromeStealer_ground/main, the C2 server under /chromeStealer_ground/server
Please enjoy! Thank you very much. 
Eddie, Zeyang, Max

The original repo is currently private and contains actual credentials from testing. Please use this repo to gain insights of the details in our code. 

Here are our contributions:
Eddie lead the development of this project, including the main implant design and development, RPC and encryption protocols, C2 server backend/frontend and testing
Zeyang developed the named pipe daisy chained special feature, participated in the development of task execution and final testing for the malware. 
Max developed the implant dropper with advanced defense evasion mechanisms, built solution for high obfuscated code.


## Highlights 
### Double Rachet Encryption 

Except for standard HTTPS, any traffic between the Server and Implants is encrypted using AEAD, ensuring confidentiality, authenticity, integriy and forward secrecy. 
The symmetric keys for encryption will be dynamically generate from master symmetric keys each session, and a new master symmetric key will be negotiated each session (5 communications).

### Fully randomized Metadata/URL

During C2 communication, there will be unencrypted metadata for C2 to decide which key to use to decrypt the traffic. The metadata is randomized each time the traffic is sent, making sure there is no informative data to identify the malicious content from other network traffic for IDS or manual inspection.

### Minimized attack surface in C2 server 
The C2 server endpoint for receiving the message is usually vulnerable to adversaries. In our server, the endpoint's URL is also randomized each time the implant connects. This can ensure that every message reaches to the server is authenticated before the server even digests it. Thus, unauthenticated traffic (blue team trying to take down or hack our server) will be minimized.

### Named Pipe traffic Proxying 
Most of the times, the network segmentation and firewalls in an organization prevent unauthorized traffic flowing out the the internet, making the implant connecting to C2 impossible. To ensure our implant is still functional under network segmentation, our implant is capable of proxying traffic from other implants that can't connect to server.
Our server and backend are built with this in mind too, they support the control of multiple implants connection simultaneously with no sacrifice in encryption or performance.

### String / Code Obfuscation
To prevent reverse engineering to our code, we added string / code obfuscation. Each string is encrypted with a different encryption key, and will be decrypted on spot by an inline function when being used. Although all data (string and key) will be stored in gloabal data memory,  Our dropper is using even more intensive code obfuscation, it defines it's own function call procedures from assembly language level, causing huge trouble to reverse engineers.

## Building Blocks 
1. **Python Flask** - C2 server [2]
Versatile, easy to use, flexible and lightweight. Bundles with SQL ORM as well.  
2. **Postgresql** - C2 database [3]
Support multi-user interaction, high performance
3. **Libsodium** - Key negotiation/Encryption [4]
Originally in C, Comes with Python binding [5], provides powerful cryptography interfaces. Can be statically compiled to main implant
4. **Nanopb/Protobuf** - RPC [6] [7]
Lightweight implementation of Google Protobuf. Seamlessly interact with python Protobuf, making customizable remote procedure call possible. 
5. **LAIKA box**- Code/string obfuscation  [8]
Generates Obfuscated string automatically, provides interface to decrypt the string
## Key Concepts
1. **Client_guid**: 
This is the unique identifier for each implant. At deployment, the implant will generate a unique ID to let server identify itself. It remains unchange during the implants' lifetime
2. **Beacon message**:
It's the message that will be regularly sent to the server in a fixed amount of time interval. It has 2 purposes: tell the server that the implant is still alive and retrieve the task it needs to perform from the server.
3. **Encasulation**:
To prevent information disclosure, the implant will encasulate any meaningful data inside another message. The final message exposed on the internet will have these two fields: 1. **client_guid_ephemeral**,  2. **ciphertext**. Note **client_guid_ephemeral** is different from the original real guid and will be changed each time the communication happens.
4. **Ratcheting**
The server and the implant will use the same algorithm to generate symmetric keys. Therefore, as long as the root key is the same, any keys generated afterwards will be the same. Each time the implant connects the server, a new ratchet will be performed on both server and the implant.

6. **session_key_x**
Each implant will have 3 **symmetric keys**. **session_key_send**, **session_key_rcv** and **client_guid_ephemeral**. 
**session_key_send** : encrypt any information goes out from the implant
**session_key_rcv**: decrypt any information goes in to the implant (i.e. from server)
**client_guid_ephemeral**: Used to authenticate the encapsulated message, changing everytime to avoid detection

7. **nonce_x**
Apart from session keys mentioned above, AEAD needs an additional data to authenticate and ensure the integrity of the data, a.k.a the **nonce**. These will be genereated dynamically along with the session keys as well. (nonce_send, nonce_rcv) Besides the sending and receiving session keys, a nonce-like data called "**suburl_bin**" will also be generated along with the **client_guid_ephemeral**. The suburl_bin will then generate a random URL string, then send it to the server. The server will only accept the **URL associated with the client_guid_ephemeral** .

8. **key_kdf_x**
This is the key used to generate **symmetric key** and **client_guid_ephmeral** for each communication. Each implant will have 3 different kdf keys to generate 3 different symmetric keys.


## Features
The key features for our implant has been implemented in these header files
### internet.h
It includes macros that will be used for any connection related features and a function (**connectServer()**) that will be used to send request to and retrieve response from server. When executes, the function will take in a binary buffer, a URL address and send it along to the server. It will give the answer back to the caller. 

### beacon.h
It has 2 major functionalities: key negotiation with the server to generate a new master symmetric key, and send beacon message to server. The beacon message contains only the client guid.  
- **key_negotiation** will first generate an RSA key pair, encrypt the client_public key with the hardcoded Server's public key Then send it to the "/register" directory. The server will send back a new public key dedicated for the implant and the session. After that, they will both generated the 3 session_keys and the associated data we have mentioned above. 
- **beacon_c2** will send beacon message to the server, and get back the task opcode and arguments. These processes involves all-time encryption of course 

### exec.h
It contains function that will parse the task opcode and arguments, and perform certain operations based on the task opcode, interesting functions contains:
- Situation awareness
- Shell command execution
- Download files to host
- Upload files to server
- Steal credentials stored in chrome

### pipe_server_client.h
If the implant is able to connect to the C2 server, it will enter **pipe server mode**, otherwise it will enter **pipe client mode**.

In pipe server mode, the implant consists of 3 threads.  The main thread, listener thread and the pipe thread. The main thread executes the main functions, and the listener thread will keep listening for incoming pipe request. The pipe thread will remain stuck until there is a valid pipe broadcast message.

In pipe client mode, the implant will send out a broadcast message to port 6983 of all interfaces. Once the server picks it up, it will keeps the normal operation as if it has network connection.

However, there is one problem with the pipe client mode. Since the endpoint URL is randomized each time for each implant, the pipe server does not know which URL it needs to send to for the pipe client. Therefore, the client has to append the intended URL before the encrypted message for the pipe server.
If the adversary is able to intercept the message between the pipes and stop it from reaching out to server, record the first 256 bytes and start a DOS attack, they will have a higher chance of success since now our server is expecting that URL. 

### laikabox.h/strings_main.h
Laikabox.h defines 2 inline functions that will be used to decrypt the data presented in strings_main.h. The strings are defined in **vboxgen.c** and the header files will be generated by **vboxgen.exe**

#### References:
[1] SentinelOne: https://www.sentinelone.com/cybersecurity-101/what-are-command-control-c2-servers/#:~:text=C2%20servers%20facilitate%20data%20exfiltration,documents%2C%20or%20other%20valuable%20information.

[2] Flask Doc: https://flask.palletsprojects.com/en/3.0.x/

[3] Postgresql: https://www.postgresql.org/

[4] Libsodium: https://doc.libsodium.org/

[5] Pynacl: https://pynacl.readthedocs.io/en/latest/

[6] Nanopb: https://github.com/nanopb/nanopb

[7] Protobuf: https://protobuf.dev/
To any potential GitHub employees looking at this: this is for a Northeastern
University course https://github.com/kbsec/malware-course-public/ and is not
being used on any actual people. All malware is being run inside a
course-provided sandbox and is for homework only. Thank you.
