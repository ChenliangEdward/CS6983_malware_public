#!/usr/bin/env python3
"""Basically xxd -i"""
import sys


def clean(s):
    result = ""
    for c in s:
        result += c if c.isalnum() else "_"
    return result


filename = sys.argv[1]
entrypoint = sys.argv[2]
with open(filename, "rb") as f:
    data = f.read()
# The includes
print("#include <windows.h>")
print("#include <winternl.h>")
print('#include "mmLoader.h"')
print("typedef uintptr_t uword;")
print(
    r"""
#define CRASH() __asm__("ud2")
#define DIE(...) CRASH()
#define DECLARE(f) __typeof__(f) *my##f = NULL;
#define CHECK(cond, msg)                             \
  if (!(cond)) {                                     \
    DIE("Error: check %s failed: %s\n", #cond, msg); \
  }
static DWORD hashOf(const char *data) {
  // https://cocomelonc.github.io/tutorial/2022/04/02/malware-injection-18.html
  DWORD hash = 0x35;
  for (int i = 0; i < data[i] != '\0'; i++) {
    hash += data[i] + (hash << 1);
  }
  return hash;
}
HMODULE FindKernel32() {
  PPEB pebPtr = NtCurrentTeb()->ProcessEnvironmentBlock;
  PPEB_LDR_DATA ldr = pebPtr->Ldr;
  PLIST_ENTRY head = &ldr->InMemoryOrderModuleList;
  PLIST_ENTRY kernel_exe = head->Flink;
  PLIST_ENTRY ntdll_dll = kernel_exe->Flink;
  PLIST_ENTRY kernel32_dll = ntdll_dll->Flink;
  return CONTAINING_RECORD(kernel32_dll, LDR_DATA_TABLE_ENTRY,
                           InMemoryOrderLinks)
      ->DllBase;
}
static LPVOID FindFuncInModule(HMODULE h, DWORD myHash) {
  // https://cocomelonc.github.io/tutorial/2022/04/02/malware-injection-18.html
  PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)h;
  CHECK(img_dos_header->e_magic == 0x5A4D, "bad dos header magic");
  PIMAGE_NT_HEADERS img_nt_header =
      (PIMAGE_NT_HEADERS)((LPBYTE)h + img_dos_header->e_lfanew);
  CHECK(img_nt_header->Signature == 0x4550, "bad header signature");
  PIMAGE_EXPORT_DIRECTORY img_edt =
      (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)h +
                                img_nt_header->OptionalHeader
                                    .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]
                                    .VirtualAddress);
  PDWORD fAddr = (PDWORD)((LPBYTE)h + img_edt->AddressOfFunctions);
  PDWORD fNames = (PDWORD)((LPBYTE)h + img_edt->AddressOfNames);
  PWORD fOrd = (PWORD)((LPBYTE)h + img_edt->AddressOfNameOrdinals);
  for (DWORD i = 0; i < img_edt->AddressOfFunctions; i++) {
    LPSTR pFuncName = (LPSTR)((LPBYTE)h + fNames[i]);
    if (hashOf(pFuncName) == myHash) {
      return (LPVOID)((LPBYTE)h + fAddr[fOrd[i]]);
    }
  }
  DIE("[!] Failed to find GetProcAddress\n");
}
"""
)
# The DLL data
cleaned_filename = clean(filename)
print(f"unsigned char {cleaned_filename}[] = {{")
print(", ".join([f"0x{b:02x}" for b in data]))
print("};")
print(f"unsigned long {cleaned_filename}_len = {len(data)};")
# The main function
print(
    f"""
BOOL {entrypoint}() {{
  DWORD dwError = 0;
  HMEMMODULE mod = LoadMemModule({cleaned_filename}, {cleaned_filename}_len, &dwError);
  if (!mod) {{
    return FALSE;
  }}
  void (*entrypoint)() = (void (*)())GetMemModuleProc(mod, "{entrypoint}");
  (*entrypoint)();
  return TRUE;
}}
void UnpackSelf() {{
  const uword hash_GetProcAddress = 0x000000001ac1e8e1;
  const uword hash_LoadLibraryA = 0x00000000030aa4dd;
  HMODULE kernel32 = FindKernel32();
  HMODULE hurlmon = NULL;
  DECLARE(GetProcAddress)
  DECLARE(LoadLibraryA)
  myGetProcAddress = FindFuncInModule(kernel32, hash_GetProcAddress);
  myLoadLibraryA = FindFuncInModule(kernel32, hash_LoadLibraryA);
  InitApiTable(myLoadLibraryA);
}}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {{
  switch (fdwReason) {{
  case DLL_PROCESS_ATTACH:
    UnpackSelf();
    break;
  case DLL_PROCESS_DETACH:
    break;
  case DLL_THREAD_ATTACH:
    break;
  case DLL_THREAD_DETACH:
    break;
  }}
  return TRUE;
}}
"""
)
